// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/core/connection/v1/connection.proto (package ibc.core.connection.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { MerklePrefix } from "../../commitment/v1/commitment_pb.js";
/**
 * State defines if a connection is in one of the following states:
 * INIT, TRYOPEN, OPEN or UNINITIALIZED.
 *
 * @generated from enum ibc.core.connection.v1.State
 */
export var State;
(function (State) {
    /**
     * Default State
     *
     * @generated from enum value: STATE_UNINITIALIZED_UNSPECIFIED = 0;
     */
    State[State["UNINITIALIZED_UNSPECIFIED"] = 0] = "UNINITIALIZED_UNSPECIFIED";
    /**
     * A connection end has just started the opening handshake.
     *
     * @generated from enum value: STATE_INIT = 1;
     */
    State[State["INIT"] = 1] = "INIT";
    /**
     * A connection end has acknowledged the handshake step on the counterparty
     * chain.
     *
     * @generated from enum value: STATE_TRYOPEN = 2;
     */
    State[State["TRYOPEN"] = 2] = "TRYOPEN";
    /**
     * A connection end has completed the handshake.
     *
     * @generated from enum value: STATE_OPEN = 3;
     */
    State[State["OPEN"] = 3] = "OPEN";
})(State || (State = {}));
// Retrieve enum metadata with: proto3.getEnumType(State)
proto3.util.setEnumType(State, "ibc.core.connection.v1.State", [
    { no: 0, name: "STATE_UNINITIALIZED_UNSPECIFIED" },
    { no: 1, name: "STATE_INIT" },
    { no: 2, name: "STATE_TRYOPEN" },
    { no: 3, name: "STATE_OPEN" },
]);
/**
 * ConnectionEnd defines a stateful object on a chain connected to another
 * separate one.
 * NOTE: there must only be 2 defined ConnectionEnds to establish
 * a connection between two chains.
 *
 * @generated from message ibc.core.connection.v1.ConnectionEnd
 */
export class ConnectionEnd extends Message {
    constructor(data) {
        super();
        /**
         * client associated with this connection.
         *
         * @generated from field: string client_id = 1;
         */
        this.clientId = "";
        /**
         * IBC version which can be utilised to determine encodings or protocols for
         * channels or packets utilising this connection.
         *
         * @generated from field: repeated ibc.core.connection.v1.Version versions = 2;
         */
        this.versions = [];
        /**
         * current state of the connection end.
         *
         * @generated from field: ibc.core.connection.v1.State state = 3;
         */
        this.state = State.UNINITIALIZED_UNSPECIFIED;
        /**
         * delay period that must pass before a consensus state can be used for
         * packet-verification NOTE: delay period logic is only implemented by some
         * clients.
         *
         * @generated from field: uint64 delay_period = 5;
         */
        this.delayPeriod = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ConnectionEnd().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ConnectionEnd().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ConnectionEnd().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ConnectionEnd, a, b);
    }
}
ConnectionEnd.runtime = proto3;
ConnectionEnd.typeName = "ibc.core.connection.v1.ConnectionEnd";
ConnectionEnd.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "versions", kind: "message", T: Version, repeated: true },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 4, name: "counterparty", kind: "message", T: Counterparty },
    { no: 5, name: "delay_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * IdentifiedConnection defines a connection with additional connection
 * identifier field.
 *
 * @generated from message ibc.core.connection.v1.IdentifiedConnection
 */
export class IdentifiedConnection extends Message {
    constructor(data) {
        super();
        /**
         * connection identifier.
         *
         * @generated from field: string id = 1;
         */
        this.id = "";
        /**
         * client associated with this connection.
         *
         * @generated from field: string client_id = 2;
         */
        this.clientId = "";
        /**
         * IBC version which can be utilised to determine encodings or protocols for
         * channels or packets utilising this connection
         *
         * @generated from field: repeated ibc.core.connection.v1.Version versions = 3;
         */
        this.versions = [];
        /**
         * current state of the connection end.
         *
         * @generated from field: ibc.core.connection.v1.State state = 4;
         */
        this.state = State.UNINITIALIZED_UNSPECIFIED;
        /**
         * delay period associated with this connection.
         *
         * @generated from field: uint64 delay_period = 6;
         */
        this.delayPeriod = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new IdentifiedConnection().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new IdentifiedConnection().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new IdentifiedConnection().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(IdentifiedConnection, a, b);
    }
}
IdentifiedConnection.runtime = proto3;
IdentifiedConnection.typeName = "ibc.core.connection.v1.IdentifiedConnection";
IdentifiedConnection.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "versions", kind: "message", T: Version, repeated: true },
    { no: 4, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 5, name: "counterparty", kind: "message", T: Counterparty },
    { no: 6, name: "delay_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * Counterparty defines the counterparty chain associated with a connection end.
 *
 * @generated from message ibc.core.connection.v1.Counterparty
 */
export class Counterparty extends Message {
    constructor(data) {
        super();
        /**
         * identifies the client on the counterparty chain associated with a given
         * connection.
         *
         * @generated from field: string client_id = 1;
         */
        this.clientId = "";
        /**
         * identifies the connection end on the counterparty chain associated with a
         * given connection.
         *
         * @generated from field: string connection_id = 2;
         */
        this.connectionId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Counterparty().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Counterparty().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Counterparty().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Counterparty, a, b);
    }
}
Counterparty.runtime = proto3;
Counterparty.typeName = "ibc.core.connection.v1.Counterparty";
Counterparty.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "prefix", kind: "message", T: MerklePrefix },
]);
/**
 * ClientPaths define all the connection paths for a client state.
 *
 * @generated from message ibc.core.connection.v1.ClientPaths
 */
export class ClientPaths extends Message {
    constructor(data) {
        super();
        /**
         * list of connection paths
         *
         * @generated from field: repeated string paths = 1;
         */
        this.paths = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ClientPaths().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClientPaths().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClientPaths().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ClientPaths, a, b);
    }
}
ClientPaths.runtime = proto3;
ClientPaths.typeName = "ibc.core.connection.v1.ClientPaths";
ClientPaths.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * ConnectionPaths define all the connection paths for a given client state.
 *
 * @generated from message ibc.core.connection.v1.ConnectionPaths
 */
export class ConnectionPaths extends Message {
    constructor(data) {
        super();
        /**
         * client state unique identifier
         *
         * @generated from field: string client_id = 1;
         */
        this.clientId = "";
        /**
         * list of connection paths
         *
         * @generated from field: repeated string paths = 2;
         */
        this.paths = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ConnectionPaths().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ConnectionPaths().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ConnectionPaths().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ConnectionPaths, a, b);
    }
}
ConnectionPaths.runtime = proto3;
ConnectionPaths.typeName = "ibc.core.connection.v1.ConnectionPaths";
ConnectionPaths.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * Version defines the versioning scheme used to negotiate the IBC version in
 * the connection handshake.
 *
 * @generated from message ibc.core.connection.v1.Version
 */
export class Version extends Message {
    constructor(data) {
        super();
        /**
         * unique version identifier
         *
         * @generated from field: string identifier = 1;
         */
        this.identifier = "";
        /**
         * list of features compatible with the specified identifier
         *
         * @generated from field: repeated string features = 2;
         */
        this.features = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Version().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Version().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Version().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Version, a, b);
    }
}
Version.runtime = proto3;
Version.typeName = "ibc.core.connection.v1.Version";
Version.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * Params defines the set of Connection parameters.
 *
 * @generated from message ibc.core.connection.v1.Params
 */
export class Params extends Message {
    constructor(data) {
        super();
        /**
         * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
         * largest amount of time that the chain might reasonably take to produce the next block under normal operating
         * conditions. A safe choice is 3-5x the expected time per block.
         *
         * @generated from field: uint64 max_expected_time_per_block = 1;
         */
        this.maxExpectedTimePerBlock = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Params().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Params().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Params().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Params, a, b);
    }
}
Params.runtime = proto3;
Params.typeName = "ibc.core.connection.v1.Params";
Params.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "max_expected_time_per_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
//# sourceMappingURL=connection_pb.js.map