import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Coin } from "../../../../cosmos/base/v1beta1/coin_pb.js";
/**
 * Parameters for changing the weights in a balancer pool smoothly from
 * a start weight and end weight over a period of time.
 * Currently, the only smooth change supported is linear changing between
 * the two weights, but more types may be added in the future.
 * When these parameters are set, the weight w(t) for pool time `t` is the
 * following:
 *   t <= start_time: w(t) = initial_pool_weights
 *   start_time < t <= start_time + duration:
 *     w(t) = initial_pool_weights + (t - start_time) *
 *       (target_pool_weights - initial_pool_weights) / (duration)
 *   t > start_time + duration: w(t) = target_pool_weights
 *
 * @generated from message dymensionxyz.dymension.gamm.v1beta1.SmoothWeightChangeParams
 */
export declare class SmoothWeightChangeParams extends Message<SmoothWeightChangeParams> {
    /**
     * The start time for beginning the weight change.
     * If a parameter change / pool instantiation leaves this blank,
     * it should be generated by the state_machine as the current time.
     *
     * @generated from field: google.protobuf.Timestamp start_time = 1;
     */
    startTime?: Timestamp;
    /**
     * Duration for the weights to change over
     *
     * @generated from field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
    /**
     * The initial pool weights. These are copied from the pool's settings
     * at the time of weight change instantiation.
     * The amount PoolAsset.token.amount field is ignored if present,
     * future type refactorings should just have a type with the denom & weight
     * here.
     *
     * @generated from field: repeated dymensionxyz.dymension.gamm.v1beta1.PoolAsset initial_pool_weights = 3;
     */
    initialPoolWeights: PoolAsset[];
    /**
     * The target pool weights. The pool weights will change linearly with respect
     * to time between start_time, and start_time + duration. The amount
     * PoolAsset.token.amount field is ignored if present, future type
     * refactorings should just have a type with the denom & weight here.
     *
     * Intermediate variable for the 'slope' of pool weights. This is equal to
     * (target_pool_weights - initial_pool_weights) / (duration)
     * TODO: Work out precision, and decide if this is good to add
     * repeated PoolAsset poolWeightSlope = 5 [
     *  (gogoproto.moretags) = "yaml:\"pool_weight_slope\"",
     *  (gogoproto.nullable) = false
     * ];
     *
     * @generated from field: repeated dymensionxyz.dymension.gamm.v1beta1.PoolAsset target_pool_weights = 4;
     */
    targetPoolWeights: PoolAsset[];
    constructor(data?: PartialMessage<SmoothWeightChangeParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "dymensionxyz.dymension.gamm.v1beta1.SmoothWeightChangeParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SmoothWeightChangeParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SmoothWeightChangeParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SmoothWeightChangeParams;
    static equals(a: SmoothWeightChangeParams | PlainMessage<SmoothWeightChangeParams> | undefined, b: SmoothWeightChangeParams | PlainMessage<SmoothWeightChangeParams> | undefined): boolean;
}
/**
 * PoolParams defined the parameters that will be managed by the pool
 * governance in the future. This params are not managed by the chain
 * governance. Instead they will be managed by the token holders of the pool.
 * The pool's token holders are specified in future_pool_governor.
 *
 * @generated from message dymensionxyz.dymension.gamm.v1beta1.PoolParams
 */
export declare class PoolParams extends Message<PoolParams> {
    /**
     * @generated from field: string swap_fee = 1;
     */
    swapFee: string;
    /**
     * @generated from field: string exit_fee = 2;
     */
    exitFee: string;
    /**
     * @generated from field: dymensionxyz.dymension.gamm.v1beta1.SmoothWeightChangeParams smooth_weight_change_params = 3;
     */
    smoothWeightChangeParams?: SmoothWeightChangeParams;
    constructor(data?: PartialMessage<PoolParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "dymensionxyz.dymension.gamm.v1beta1.PoolParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PoolParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PoolParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PoolParams;
    static equals(a: PoolParams | PlainMessage<PoolParams> | undefined, b: PoolParams | PlainMessage<PoolParams> | undefined): boolean;
}
/**
 * Pool asset is an internal struct that combines the amount of the
 * token in the pool, and its balancer weight.
 * This is an awkward packaging of data,
 * and should be revisited in a future state migration.
 *
 * @generated from message dymensionxyz.dymension.gamm.v1beta1.PoolAsset
 */
export declare class PoolAsset extends Message<PoolAsset> {
    /**
     * Coins we are talking about,
     * the denomination must be unique amongst all PoolAssets for this pool.
     *
     * @generated from field: cosmos.base.v1beta1.Coin token = 1;
     */
    token?: Coin;
    /**
     * Weight that is not normalized. This weight must be less than 2^50
     *
     * @generated from field: string weight = 2;
     */
    weight: string;
    constructor(data?: PartialMessage<PoolAsset>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "dymensionxyz.dymension.gamm.v1beta1.PoolAsset";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PoolAsset;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PoolAsset;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PoolAsset;
    static equals(a: PoolAsset | PlainMessage<PoolAsset> | undefined, b: PoolAsset | PlainMessage<PoolAsset> | undefined): boolean;
}
/**
 * @generated from message dymensionxyz.dymension.gamm.v1beta1.Pool
 */
export declare class Pool extends Message<Pool> {
    /**
     * @generated from field: string address = 1;
     */
    address: string;
    /**
     * @generated from field: uint64 id = 2;
     */
    id: bigint;
    /**
     * @generated from field: dymensionxyz.dymension.gamm.v1beta1.PoolParams pool_params = 3;
     */
    poolParams?: PoolParams;
    /**
     * This string specifies who will govern the pool in the future.
     * Valid forms of this are:
     * {token name},{duration}
     * {duration}
     * where {token name} if specified is the token which determines the
     * governor, and if not specified is the LP token for this pool.duration is
     * a time specified as 0w,1w,2w, etc. which specifies how long the token
     * would need to be locked up to count in governance. 0w means no lockup.
     * TODO: Further improve these docs
     *
     * @generated from field: string future_pool_governor = 4;
     */
    futurePoolGovernor: string;
    /**
     * sum of all LP tokens sent out
     *
     * @generated from field: cosmos.base.v1beta1.Coin total_shares = 5;
     */
    totalShares?: Coin;
    /**
     * These are assumed to be sorted by denomiation.
     * They contain the pool asset and the information about the weight
     *
     * @generated from field: repeated dymensionxyz.dymension.gamm.v1beta1.PoolAsset pool_assets = 6;
     */
    poolAssets: PoolAsset[];
    /**
     * sum of all non-normalized pool weights
     *
     * @generated from field: string total_weight = 7;
     */
    totalWeight: string;
    constructor(data?: PartialMessage<Pool>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "dymensionxyz.dymension.gamm.v1beta1.Pool";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pool;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pool;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pool;
    static equals(a: Pool | PlainMessage<Pool> | undefined, b: Pool | PlainMessage<Pool> | undefined): boolean;
}
//# sourceMappingURL=balancerPool_pb.d.ts.map