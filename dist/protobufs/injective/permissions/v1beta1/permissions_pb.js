// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/permissions/v1beta1/permissions.proto (package injective.permissions.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
/**
 * each Action enum value should be a power of two
 *
 * @generated from enum injective.permissions.v1beta1.Action
 */
export var Action;
(function (Action) {
    /**
     * @generated from enum value: UNSPECIFIED = 0;
     */
    Action[Action["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from enum value: MINT = 1;
     */
    Action[Action["MINT"] = 1] = "MINT";
    /**
     * @generated from enum value: RECEIVE = 2;
     */
    Action[Action["RECEIVE"] = 2] = "RECEIVE";
    /**
     * @generated from enum value: BURN = 4;
     */
    Action[Action["BURN"] = 4] = "BURN";
})(Action || (Action = {}));
// Retrieve enum metadata with: proto3.getEnumType(Action)
proto3.util.setEnumType(Action, "injective.permissions.v1beta1.Action", [
    { no: 0, name: "UNSPECIFIED" },
    { no: 1, name: "MINT" },
    { no: 2, name: "RECEIVE" },
    { no: 4, name: "BURN" },
]);
/**
 * Namespace defines a permissions namespace
 *
 * @generated from message injective.permissions.v1beta1.Namespace
 */
export class Namespace extends Message {
    constructor(data) {
        super();
        /**
         * tokenfactory denom to which this namespace applies to
         *
         * @generated from field: string denom = 1;
         */
        this.denom = "";
        /**
         * address of smart contract to apply code-based restrictions
         *
         * @generated from field: string wasm_hook = 2;
         */
        this.wasmHook = "";
        /**
         * @generated from field: bool mints_paused = 3;
         */
        this.mintsPaused = false;
        /**
         * @generated from field: bool sends_paused = 4;
         */
        this.sendsPaused = false;
        /**
         * @generated from field: bool burns_paused = 5;
         */
        this.burnsPaused = false;
        /**
         * permissions for each role
         *
         * @generated from field: map<string, uint32> role_permissions = 6;
         */
        this.rolePermissions = {};
        /**
         * @generated from field: map<string, injective.permissions.v1beta1.Roles> address_roles = 7;
         */
        this.addressRoles = {};
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Namespace().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Namespace().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Namespace().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Namespace, a, b);
    }
}
Namespace.runtime = proto3;
Namespace.typeName = "injective.permissions.v1beta1.Namespace";
Namespace.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wasm_hook", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mints_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "sends_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "burns_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "role_permissions", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "scalar", T: 13 /* ScalarType.UINT32 */ } },
    { no: 7, name: "address_roles", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: Roles } },
]);
/**
 * Role is only used for storage
 *
 * @generated from message injective.permissions.v1beta1.Role
 */
export class Role extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string name = 1;
         */
        this.name = "";
        /**
         * @generated from field: uint32 permissions = 2;
         */
        this.permissions = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Role().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Role().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Role().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Role, a, b);
    }
}
Role.runtime = proto3;
Role.typeName = "injective.permissions.v1beta1.Role";
Role.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "permissions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * @generated from message injective.permissions.v1beta1.Roles
 */
export class Roles extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string roles = 1;
         */
        this.roles = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Roles().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Roles().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Roles().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Roles, a, b);
    }
}
Roles.runtime = proto3;
Roles.typeName = "injective.permissions.v1beta1.Roles";
Roles.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * used in storage
 *
 * @generated from message injective.permissions.v1beta1.RoleIDs
 */
export class RoleIDs extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated uint32 role_ids = 1;
         */
        this.roleIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new RoleIDs().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RoleIDs().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RoleIDs().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(RoleIDs, a, b);
    }
}
RoleIDs.runtime = proto3;
RoleIDs.typeName = "injective.permissions.v1beta1.RoleIDs";
RoleIDs.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "role_ids", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
]);
/**
 * @generated from message injective.permissions.v1beta1.Voucher
 */
export class Voucher extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin coins = 1;
         */
        this.coins = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Voucher().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Voucher().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Voucher().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Voucher, a, b);
    }
}
Voucher.runtime = proto3;
Voucher.typeName = "injective.permissions.v1beta1.Voucher";
Voucher.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "coins", kind: "message", T: Coin, repeated: true },
]);
//# sourceMappingURL=permissions_pb.js.map