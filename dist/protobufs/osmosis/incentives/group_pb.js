// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/incentives/group.proto (package osmosis.incentives, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Gauge } from "./gauge_pb.js";
/**
 * SplittingPolicy determines the way we want to split incentives in groupGauges
 *
 * @generated from enum osmosis.incentives.SplittingPolicy
 */
export var SplittingPolicy;
(function (SplittingPolicy) {
    /**
     * @generated from enum value: ByVolume = 0;
     */
    SplittingPolicy[SplittingPolicy["ByVolume"] = 0] = "ByVolume";
})(SplittingPolicy || (SplittingPolicy = {}));
// Retrieve enum metadata with: proto3.getEnumType(SplittingPolicy)
proto3.util.setEnumType(SplittingPolicy, "osmosis.incentives.SplittingPolicy", [
    { no: 0, name: "ByVolume" },
]);
/**
 * Note that while both InternalGaugeInfo and InternalGaugeRecord could
 * technically be replaced by DistrInfo and DistrRecord from the pool-incentives
 * module, we create separate types here to keep our abstractions clean and
 * readable (pool-incentives distribution abstractions are used in a very
 * specific way that does not directly relate to gauge logic). This also helps
 * us sidestep a refactor to avoid an import cycle.
 *
 * @generated from message osmosis.incentives.InternalGaugeInfo
 */
export class InternalGaugeInfo extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string total_weight = 1;
         */
        this.totalWeight = "";
        /**
         * @generated from field: repeated osmosis.incentives.InternalGaugeRecord gauge_records = 2;
         */
        this.gaugeRecords = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InternalGaugeInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InternalGaugeInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InternalGaugeInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InternalGaugeInfo, a, b);
    }
}
InternalGaugeInfo.runtime = proto3;
InternalGaugeInfo.typeName = "osmosis.incentives.InternalGaugeInfo";
InternalGaugeInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "total_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "gauge_records", kind: "message", T: InternalGaugeRecord, repeated: true },
]);
/**
 * @generated from message osmosis.incentives.InternalGaugeRecord
 */
export class InternalGaugeRecord extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 gauge_id = 1;
         */
        this.gaugeId = protoInt64.zero;
        /**
         * CurrentWeight is the current weight of this gauge being distributed to for
         * this epoch. For instance, for volume splitting policy, this stores the
         * volume generated in the last epoch of the linked pool.
         *
         * @generated from field: string current_weight = 2;
         */
        this.currentWeight = "";
        /**
         * CumulativeWeight serves as a snapshot of the accumulator being tracked
         * based on splitting policy. For instance, for volume splitting policy, this
         * stores the cumulative volume for the linked pool at time of last update.
         *
         * @generated from field: string cumulative_weight = 3;
         */
        this.cumulativeWeight = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InternalGaugeRecord().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InternalGaugeRecord().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InternalGaugeRecord().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InternalGaugeRecord, a, b);
    }
}
InternalGaugeRecord.runtime = proto3;
InternalGaugeRecord.typeName = "osmosis.incentives.InternalGaugeRecord";
InternalGaugeRecord.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "current_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cumulative_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * Group is an object that stores a 1:1 mapped gauge ID, a list of pool gauge
 * info, and a splitting policy. These are grouped into a single abstraction to
 * allow for distribution of group incentives to internal gauges according to
 * the specified splitting policy.
 *
 * @generated from message osmosis.incentives.Group
 */
export class Group extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 group_gauge_id = 1;
         */
        this.groupGaugeId = protoInt64.zero;
        /**
         * @generated from field: osmosis.incentives.SplittingPolicy splitting_policy = 3;
         */
        this.splittingPolicy = SplittingPolicy.ByVolume;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Group().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Group().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Group().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Group, a, b);
    }
}
Group.runtime = proto3;
Group.typeName = "osmosis.incentives.Group";
Group.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "group_gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "internal_gauge_info", kind: "message", T: InternalGaugeInfo },
    { no: 3, name: "splitting_policy", kind: "enum", T: proto3.getEnumType(SplittingPolicy) },
]);
/**
 * CreateGroup is called via governance to create a new group.
 * It takes an array of pool IDs to split the incentives across.
 *
 * @generated from message osmosis.incentives.CreateGroup
 */
export class CreateGroup extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated uint64 pool_ids = 1;
         */
        this.poolIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CreateGroup().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CreateGroup().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CreateGroup().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CreateGroup, a, b);
    }
}
CreateGroup.runtime = proto3;
CreateGroup.typeName = "osmosis.incentives.CreateGroup";
CreateGroup.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
]);
/**
 * GroupsWithGauge is a helper struct that stores a group and its
 * associated gauge.
 *
 * @generated from message osmosis.incentives.GroupsWithGauge
 */
export class GroupsWithGauge extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new GroupsWithGauge().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GroupsWithGauge().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GroupsWithGauge().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GroupsWithGauge, a, b);
    }
}
GroupsWithGauge.runtime = proto3;
GroupsWithGauge.typeName = "osmosis.incentives.GroupsWithGauge";
GroupsWithGauge.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "group", kind: "message", T: Group },
    { no: 2, name: "gauge", kind: "message", T: Gauge },
]);
//# sourceMappingURL=group_pb.js.map