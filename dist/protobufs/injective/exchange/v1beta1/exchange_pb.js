// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/exchange.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";
/**
 * @generated from enum injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
 */
export var AtomicMarketOrderAccessLevel;
(function (AtomicMarketOrderAccessLevel) {
    /**
     * @generated from enum value: Nobody = 0;
     */
    AtomicMarketOrderAccessLevel[AtomicMarketOrderAccessLevel["Nobody"] = 0] = "Nobody";
    /**
     * currently unsupported
     *
     * @generated from enum value: BeginBlockerSmartContractsOnly = 1;
     */
    AtomicMarketOrderAccessLevel[AtomicMarketOrderAccessLevel["BeginBlockerSmartContractsOnly"] = 1] = "BeginBlockerSmartContractsOnly";
    /**
     * @generated from enum value: SmartContractsOnly = 2;
     */
    AtomicMarketOrderAccessLevel[AtomicMarketOrderAccessLevel["SmartContractsOnly"] = 2] = "SmartContractsOnly";
    /**
     * @generated from enum value: Everyone = 3;
     */
    AtomicMarketOrderAccessLevel[AtomicMarketOrderAccessLevel["Everyone"] = 3] = "Everyone";
})(AtomicMarketOrderAccessLevel || (AtomicMarketOrderAccessLevel = {}));
// Retrieve enum metadata with: proto3.getEnumType(AtomicMarketOrderAccessLevel)
proto3.util.setEnumType(AtomicMarketOrderAccessLevel, "injective.exchange.v1beta1.AtomicMarketOrderAccessLevel", [
    { no: 0, name: "Nobody" },
    { no: 1, name: "BeginBlockerSmartContractsOnly" },
    { no: 2, name: "SmartContractsOnly" },
    { no: 3, name: "Everyone" },
]);
/**
 * @generated from enum injective.exchange.v1beta1.MarketStatus
 */
export var MarketStatus;
(function (MarketStatus) {
    /**
     * @generated from enum value: Unspecified = 0;
     */
    MarketStatus[MarketStatus["Unspecified"] = 0] = "Unspecified";
    /**
     * @generated from enum value: Active = 1;
     */
    MarketStatus[MarketStatus["Active"] = 1] = "Active";
    /**
     * @generated from enum value: Paused = 2;
     */
    MarketStatus[MarketStatus["Paused"] = 2] = "Paused";
    /**
     * @generated from enum value: Demolished = 3;
     */
    MarketStatus[MarketStatus["Demolished"] = 3] = "Demolished";
    /**
     * @generated from enum value: Expired = 4;
     */
    MarketStatus[MarketStatus["Expired"] = 4] = "Expired";
})(MarketStatus || (MarketStatus = {}));
// Retrieve enum metadata with: proto3.getEnumType(MarketStatus)
proto3.util.setEnumType(MarketStatus, "injective.exchange.v1beta1.MarketStatus", [
    { no: 0, name: "Unspecified" },
    { no: 1, name: "Active" },
    { no: 2, name: "Paused" },
    { no: 3, name: "Demolished" },
    { no: 4, name: "Expired" },
]);
/**
 * @generated from enum injective.exchange.v1beta1.OrderType
 */
export var OrderType;
(function (OrderType) {
    /**
     * @generated from enum value: UNSPECIFIED = 0;
     */
    OrderType[OrderType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from enum value: BUY = 1;
     */
    OrderType[OrderType["BUY"] = 1] = "BUY";
    /**
     * @generated from enum value: SELL = 2;
     */
    OrderType[OrderType["SELL"] = 2] = "SELL";
    /**
     * @generated from enum value: STOP_BUY = 3;
     */
    OrderType[OrderType["STOP_BUY"] = 3] = "STOP_BUY";
    /**
     * @generated from enum value: STOP_SELL = 4;
     */
    OrderType[OrderType["STOP_SELL"] = 4] = "STOP_SELL";
    /**
     * @generated from enum value: TAKE_BUY = 5;
     */
    OrderType[OrderType["TAKE_BUY"] = 5] = "TAKE_BUY";
    /**
     * @generated from enum value: TAKE_SELL = 6;
     */
    OrderType[OrderType["TAKE_SELL"] = 6] = "TAKE_SELL";
    /**
     * @generated from enum value: BUY_PO = 7;
     */
    OrderType[OrderType["BUY_PO"] = 7] = "BUY_PO";
    /**
     * @generated from enum value: SELL_PO = 8;
     */
    OrderType[OrderType["SELL_PO"] = 8] = "SELL_PO";
    /**
     * @generated from enum value: BUY_ATOMIC = 9;
     */
    OrderType[OrderType["BUY_ATOMIC"] = 9] = "BUY_ATOMIC";
    /**
     * @generated from enum value: SELL_ATOMIC = 10;
     */
    OrderType[OrderType["SELL_ATOMIC"] = 10] = "SELL_ATOMIC";
})(OrderType || (OrderType = {}));
// Retrieve enum metadata with: proto3.getEnumType(OrderType)
proto3.util.setEnumType(OrderType, "injective.exchange.v1beta1.OrderType", [
    { no: 0, name: "UNSPECIFIED" },
    { no: 1, name: "BUY" },
    { no: 2, name: "SELL" },
    { no: 3, name: "STOP_BUY" },
    { no: 4, name: "STOP_SELL" },
    { no: 5, name: "TAKE_BUY" },
    { no: 6, name: "TAKE_SELL" },
    { no: 7, name: "BUY_PO" },
    { no: 8, name: "SELL_PO" },
    { no: 9, name: "BUY_ATOMIC" },
    { no: 10, name: "SELL_ATOMIC" },
]);
/**
 * @generated from enum injective.exchange.v1beta1.ExecutionType
 */
export var ExecutionType;
(function (ExecutionType) {
    /**
     * @generated from enum value: UnspecifiedExecutionType = 0;
     */
    ExecutionType[ExecutionType["UnspecifiedExecutionType"] = 0] = "UnspecifiedExecutionType";
    /**
     * @generated from enum value: Market = 1;
     */
    ExecutionType[ExecutionType["Market"] = 1] = "Market";
    /**
     * @generated from enum value: LimitFill = 2;
     */
    ExecutionType[ExecutionType["LimitFill"] = 2] = "LimitFill";
    /**
     * @generated from enum value: LimitMatchRestingOrder = 3;
     */
    ExecutionType[ExecutionType["LimitMatchRestingOrder"] = 3] = "LimitMatchRestingOrder";
    /**
     * @generated from enum value: LimitMatchNewOrder = 4;
     */
    ExecutionType[ExecutionType["LimitMatchNewOrder"] = 4] = "LimitMatchNewOrder";
    /**
     * @generated from enum value: MarketLiquidation = 5;
     */
    ExecutionType[ExecutionType["MarketLiquidation"] = 5] = "MarketLiquidation";
    /**
     * @generated from enum value: ExpiryMarketSettlement = 6;
     */
    ExecutionType[ExecutionType["ExpiryMarketSettlement"] = 6] = "ExpiryMarketSettlement";
})(ExecutionType || (ExecutionType = {}));
// Retrieve enum metadata with: proto3.getEnumType(ExecutionType)
proto3.util.setEnumType(ExecutionType, "injective.exchange.v1beta1.ExecutionType", [
    { no: 0, name: "UnspecifiedExecutionType" },
    { no: 1, name: "Market" },
    { no: 2, name: "LimitFill" },
    { no: 3, name: "LimitMatchRestingOrder" },
    { no: 4, name: "LimitMatchNewOrder" },
    { no: 5, name: "MarketLiquidation" },
    { no: 6, name: "ExpiryMarketSettlement" },
]);
/**
 * @generated from enum injective.exchange.v1beta1.OrderMask
 */
export var OrderMask;
(function (OrderMask) {
    /**
     * @generated from enum value: UNUSED = 0;
     */
    OrderMask[OrderMask["UNUSED"] = 0] = "UNUSED";
    /**
     * @generated from enum value: ANY = 1;
     */
    OrderMask[OrderMask["ANY"] = 1] = "ANY";
    /**
     * @generated from enum value: REGULAR = 2;
     */
    OrderMask[OrderMask["REGULAR"] = 2] = "REGULAR";
    /**
     * @generated from enum value: CONDITIONAL = 4;
     */
    OrderMask[OrderMask["CONDITIONAL"] = 4] = "CONDITIONAL";
    /**
     * for conditional orders means HIGHER
     *
     * @generated from enum value: DIRECTION_BUY_OR_HIGHER = 8;
     */
    OrderMask[OrderMask["DIRECTION_BUY_OR_HIGHER"] = 8] = "DIRECTION_BUY_OR_HIGHER";
    /**
     * for conditional orders means LOWER
     *
     * @generated from enum value: DIRECTION_SELL_OR_LOWER = 16;
     */
    OrderMask[OrderMask["DIRECTION_SELL_OR_LOWER"] = 16] = "DIRECTION_SELL_OR_LOWER";
    /**
     * @generated from enum value: TYPE_MARKET = 32;
     */
    OrderMask[OrderMask["TYPE_MARKET"] = 32] = "TYPE_MARKET";
    /**
     * @generated from enum value: TYPE_LIMIT = 64;
     */
    OrderMask[OrderMask["TYPE_LIMIT"] = 64] = "TYPE_LIMIT";
})(OrderMask || (OrderMask = {}));
// Retrieve enum metadata with: proto3.getEnumType(OrderMask)
proto3.util.setEnumType(OrderMask, "injective.exchange.v1beta1.OrderMask", [
    { no: 0, name: "UNUSED" },
    { no: 1, name: "ANY" },
    { no: 2, name: "REGULAR" },
    { no: 4, name: "CONDITIONAL" },
    { no: 8, name: "DIRECTION_BUY_OR_HIGHER" },
    { no: 16, name: "DIRECTION_SELL_OR_LOWER" },
    { no: 32, name: "TYPE_MARKET" },
    { no: 64, name: "TYPE_LIMIT" },
]);
/**
 * @generated from message injective.exchange.v1beta1.Params
 */
export class Params extends Message {
    constructor(data) {
        super();
        /**
         * default_spot_maker_fee defines the default exchange trade fee for makers on
         * a spot market
         *
         * @generated from field: string default_spot_maker_fee_rate = 3;
         */
        this.defaultSpotMakerFeeRate = "";
        /**
         * default_spot_taker_fee_rate defines the default exchange trade fee rate for
         * takers on a new spot market
         *
         * @generated from field: string default_spot_taker_fee_rate = 4;
         */
        this.defaultSpotTakerFeeRate = "";
        /**
         * default_derivative_maker_fee defines the default exchange trade fee for
         * makers on a new derivative market
         *
         * @generated from field: string default_derivative_maker_fee_rate = 5;
         */
        this.defaultDerivativeMakerFeeRate = "";
        /**
         * default_derivative_taker_fee defines the default exchange trade fee for
         * takers on a new derivative market
         *
         * @generated from field: string default_derivative_taker_fee_rate = 6;
         */
        this.defaultDerivativeTakerFeeRate = "";
        /**
         * default_initial_margin_ratio defines the default initial margin ratio on a
         * new derivative market
         *
         * @generated from field: string default_initial_margin_ratio = 7;
         */
        this.defaultInitialMarginRatio = "";
        /**
         * default_maintenance_margin_ratio defines the default maintenance margin
         * ratio on a new derivative market
         *
         * @generated from field: string default_maintenance_margin_ratio = 8;
         */
        this.defaultMaintenanceMarginRatio = "";
        /**
         * default_funding_interval defines the default funding interval on a
         * derivative market
         *
         * @generated from field: int64 default_funding_interval = 9;
         */
        this.defaultFundingInterval = protoInt64.zero;
        /**
         * funding_multiple defines the timestamp multiple that the funding timestamp
         * should be a multiple of
         *
         * @generated from field: int64 funding_multiple = 10;
         */
        this.fundingMultiple = protoInt64.zero;
        /**
         * relayer_fee_share_rate defines the trade fee share percentage that goes to
         * relayers
         *
         * @generated from field: string relayer_fee_share_rate = 11;
         */
        this.relayerFeeShareRate = "";
        /**
         * default_hourly_funding_rate_cap defines the default maximum absolute value
         * of the hourly funding rate
         *
         * @generated from field: string default_hourly_funding_rate_cap = 12;
         */
        this.defaultHourlyFundingRateCap = "";
        /**
         * hourly_interest_rate defines the hourly interest rate
         *
         * @generated from field: string default_hourly_interest_rate = 13;
         */
        this.defaultHourlyInterestRate = "";
        /**
         * max_derivative_order_side_count defines the maximum number of derivative
         * active orders a subaccount can have for a given orderbook side
         *
         * @generated from field: uint32 max_derivative_order_side_count = 14;
         */
        this.maxDerivativeOrderSideCount = 0;
        /**
         * inj_reward_staked_requirement_threshold defines the threshold on INJ
         * rewards after which one also needs staked INJ to receive more
         *
         * @generated from field: string inj_reward_staked_requirement_threshold = 15;
         */
        this.injRewardStakedRequirementThreshold = "";
        /**
         * the trading_rewards_vesting_duration defines the vesting times for trading
         * rewards
         *
         * @generated from field: int64 trading_rewards_vesting_duration = 16;
         */
        this.tradingRewardsVestingDuration = protoInt64.zero;
        /**
         * liquidator_reward_share_rate defines the ratio of the split of the surplus
         * collateral that goes to the liquidator
         *
         * @generated from field: string liquidator_reward_share_rate = 17;
         */
        this.liquidatorRewardShareRate = "";
        /**
         * atomic_market_order_access_level defines the required access permissions
         * for executing atomic market orders
         *
         * @generated from field: injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19;
         */
        this.atomicMarketOrderAccessLevel = AtomicMarketOrderAccessLevel.Nobody;
        /**
         * spot_atomic_market_order_fee_multiplier defines the default multiplier for
         * executing atomic market orders in spot markets
         *
         * @generated from field: string spot_atomic_market_order_fee_multiplier = 20;
         */
        this.spotAtomicMarketOrderFeeMultiplier = "";
        /**
         * derivative_atomic_market_order_fee_multiplier defines the default
         * multiplier for executing atomic market orders in derivative markets
         *
         * @generated from field: string derivative_atomic_market_order_fee_multiplier = 21;
         */
        this.derivativeAtomicMarketOrderFeeMultiplier = "";
        /**
         * binary_options_atomic_market_order_fee_multiplier defines the default
         * multiplier for executing atomic market orders in binary markets
         *
         * @generated from field: string binary_options_atomic_market_order_fee_multiplier = 22;
         */
        this.binaryOptionsAtomicMarketOrderFeeMultiplier = "";
        /**
         * minimal_protocol_fee_rate defines the minimal protocol fee rate
         *
         * @generated from field: string minimal_protocol_fee_rate = 23;
         */
        this.minimalProtocolFeeRate = "";
        /**
         * is_instant_derivative_market_launch_enabled defines whether instant
         * derivative market launch is enabled
         *
         * @generated from field: bool is_instant_derivative_market_launch_enabled = 24;
         */
        this.isInstantDerivativeMarketLaunchEnabled = false;
        /**
         * @generated from field: int64 post_only_mode_height_threshold = 25;
         */
        this.postOnlyModeHeightThreshold = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Params().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Params().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Params().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Params, a, b);
    }
}
Params.runtime = proto3;
Params.typeName = "injective.exchange.v1beta1.Params";
Params.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "default_funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "funding_multiple", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "max_derivative_order_side_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "trading_rewards_vesting_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: proto3.getEnumType(AtomicMarketOrderAccessLevel) },
    { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 24, name: "is_instant_derivative_market_launch_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 25, name: "post_only_mode_height_threshold", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.MarketFeeMultiplier
 */
export class MarketFeeMultiplier extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * @generated from field: string fee_multiplier = 2;
         */
        this.feeMultiplier = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MarketFeeMultiplier().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MarketFeeMultiplier().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MarketFeeMultiplier().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MarketFeeMultiplier, a, b);
    }
}
MarketFeeMultiplier.runtime = proto3;
MarketFeeMultiplier.typeName = "injective.exchange.v1beta1.MarketFeeMultiplier";
MarketFeeMultiplier.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeMarket
 */
export class DerivativeMarket extends Message {
    constructor(data) {
        super();
        /**
         * Ticker for the derivative contract.
         *
         * @generated from field: string ticker = 1;
         */
        this.ticker = "";
        /**
         * Oracle base currency
         *
         * @generated from field: string oracle_base = 2;
         */
        this.oracleBase = "";
        /**
         * Oracle quote currency
         *
         * @generated from field: string oracle_quote = 3;
         */
        this.oracleQuote = "";
        /**
         * Oracle type
         *
         * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
         */
        this.oracleType = OracleType.Unspecified;
        /**
         * Scale factor for oracle prices.
         *
         * @generated from field: uint32 oracle_scale_factor = 5;
         */
        this.oracleScaleFactor = 0;
        /**
         * Address of the quote currency denomination for the derivative contract
         *
         * @generated from field: string quote_denom = 6;
         */
        this.quoteDenom = "";
        /**
         * Unique market ID.
         *
         * @generated from field: string market_id = 7;
         */
        this.marketId = "";
        /**
         * initial_margin_ratio defines the initial margin ratio of a derivative
         * market
         *
         * @generated from field: string initial_margin_ratio = 8;
         */
        this.initialMarginRatio = "";
        /**
         * maintenance_margin_ratio defines the maintenance margin ratio of a
         * derivative market
         *
         * @generated from field: string maintenance_margin_ratio = 9;
         */
        this.maintenanceMarginRatio = "";
        /**
         * maker_fee_rate defines the maker fee rate of a derivative market
         *
         * @generated from field: string maker_fee_rate = 10;
         */
        this.makerFeeRate = "";
        /**
         * taker_fee_rate defines the taker fee rate of a derivative market
         *
         * @generated from field: string taker_fee_rate = 11;
         */
        this.takerFeeRate = "";
        /**
         * relayer_fee_share_rate defines the percentage of the transaction fee shared
         * with the relayer in a derivative market
         *
         * @generated from field: string relayer_fee_share_rate = 12;
         */
        this.relayerFeeShareRate = "";
        /**
         * true if the market is a perpetual market. false if the market is an expiry
         * futures market
         *
         * @generated from field: bool isPerpetual = 13;
         */
        this.isPerpetual = false;
        /**
         * Status of the market
         *
         * @generated from field: injective.exchange.v1beta1.MarketStatus status = 14;
         */
        this.status = MarketStatus.Unspecified;
        /**
         * min_price_tick_size defines the minimum tick size that the price and margin
         * required for orders in the market
         *
         * @generated from field: string min_price_tick_size = 15;
         */
        this.minPriceTickSize = "";
        /**
         * min_quantity_tick_size defines the minimum tick size of the quantity
         * required for orders in the market
         *
         * @generated from field: string min_quantity_tick_size = 16;
         */
        this.minQuantityTickSize = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeMarket, a, b);
    }
}
DerivativeMarket.runtime = proto3;
DerivativeMarket.typeName = "injective.exchange.v1beta1.DerivativeMarket";
DerivativeMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "isPerpetual", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from message injective.exchange.v1beta1.BinaryOptionsMarket
 */
export class BinaryOptionsMarket extends Message {
    constructor(data) {
        super();
        /**
         * Ticker for the derivative contract.
         *
         * @generated from field: string ticker = 1;
         */
        this.ticker = "";
        /**
         * Oracle symbol
         *
         * @generated from field: string oracle_symbol = 2;
         */
        this.oracleSymbol = "";
        /**
         * Oracle Provider
         *
         * @generated from field: string oracle_provider = 3;
         */
        this.oracleProvider = "";
        /**
         * Oracle type
         *
         * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
         */
        this.oracleType = OracleType.Unspecified;
        /**
         * Scale factor for oracle prices.
         *
         * @generated from field: uint32 oracle_scale_factor = 5;
         */
        this.oracleScaleFactor = 0;
        /**
         * expiration timestamp
         *
         * @generated from field: int64 expiration_timestamp = 6;
         */
        this.expirationTimestamp = protoInt64.zero;
        /**
         * expiration timestamp
         *
         * @generated from field: int64 settlement_timestamp = 7;
         */
        this.settlementTimestamp = protoInt64.zero;
        /**
         * admin of the market
         *
         * @generated from field: string admin = 8;
         */
        this.admin = "";
        /**
         * Address of the quote currency denomination for the binary options contract
         *
         * @generated from field: string quote_denom = 9;
         */
        this.quoteDenom = "";
        /**
         * Unique market ID.
         *
         * @generated from field: string market_id = 10;
         */
        this.marketId = "";
        /**
         * maker_fee_rate defines the maker fee rate of a binary options market
         *
         * @generated from field: string maker_fee_rate = 11;
         */
        this.makerFeeRate = "";
        /**
         * taker_fee_rate defines the taker fee rate of a derivative market
         *
         * @generated from field: string taker_fee_rate = 12;
         */
        this.takerFeeRate = "";
        /**
         * relayer_fee_share_rate defines the percentage of the transaction fee shared
         * with the relayer in a derivative market
         *
         * @generated from field: string relayer_fee_share_rate = 13;
         */
        this.relayerFeeShareRate = "";
        /**
         * Status of the market
         *
         * @generated from field: injective.exchange.v1beta1.MarketStatus status = 14;
         */
        this.status = MarketStatus.Unspecified;
        /**
         * min_price_tick_size defines the minimum tick size that the price and margin
         * required for orders in the market
         *
         * @generated from field: string min_price_tick_size = 15;
         */
        this.minPriceTickSize = "";
        /**
         * min_quantity_tick_size defines the minimum tick size of the quantity
         * required for orders in the market
         *
         * @generated from field: string min_quantity_tick_size = 16;
         */
        this.minQuantityTickSize = "";
        /**
         * @generated from field: string settlement_price = 17;
         */
        this.settlementPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BinaryOptionsMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BinaryOptionsMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BinaryOptionsMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BinaryOptionsMarket, a, b);
    }
}
BinaryOptionsMarket.runtime = proto3;
BinaryOptionsMarket.typeName = "injective.exchange.v1beta1.BinaryOptionsMarket";
BinaryOptionsMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "settlement_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.ExpiryFuturesMarketInfo
 */
export class ExpiryFuturesMarketInfo extends Message {
    constructor(data) {
        super();
        /**
         * market ID.
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * expiration_timestamp defines the expiration time for a time expiry futures
         * market.
         *
         * @generated from field: int64 expiration_timestamp = 2;
         */
        this.expirationTimestamp = protoInt64.zero;
        /**
         * expiration_twap_start_timestamp defines the start time of the TWAP
         * calculation window
         *
         * @generated from field: int64 twap_start_timestamp = 3;
         */
        this.twapStartTimestamp = protoInt64.zero;
        /**
         * expiration_twap_start_price_cumulative defines the cumulative price for the
         * start of the TWAP window
         *
         * @generated from field: string expiration_twap_start_price_cumulative = 4;
         */
        this.expirationTwapStartPriceCumulative = "";
        /**
         * settlement_price defines the settlement price for a time expiry futures
         * market.
         *
         * @generated from field: string settlement_price = 5;
         */
        this.settlementPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ExpiryFuturesMarketInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ExpiryFuturesMarketInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ExpiryFuturesMarketInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ExpiryFuturesMarketInfo, a, b);
    }
}
ExpiryFuturesMarketInfo.runtime = proto3;
ExpiryFuturesMarketInfo.typeName = "injective.exchange.v1beta1.ExpiryFuturesMarketInfo";
ExpiryFuturesMarketInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "twap_start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketInfo
 */
export class PerpetualMarketInfo extends Message {
    constructor(data) {
        super();
        /**
         * market ID.
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * hourly_funding_rate_cap defines the maximum absolute value of the hourly
         * funding rate
         *
         * @generated from field: string hourly_funding_rate_cap = 2;
         */
        this.hourlyFundingRateCap = "";
        /**
         * hourly_interest_rate defines the hourly interest rate
         *
         * @generated from field: string hourly_interest_rate = 3;
         */
        this.hourlyInterestRate = "";
        /**
         * next_funding_timestamp defines the next funding timestamp in seconds of a
         * perpetual market
         *
         * @generated from field: int64 next_funding_timestamp = 4;
         */
        this.nextFundingTimestamp = protoInt64.zero;
        /**
         * funding_interval defines the next funding interval in seconds of a
         * perpetual market.
         *
         * @generated from field: int64 funding_interval = 5;
         */
        this.fundingInterval = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PerpetualMarketInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PerpetualMarketInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PerpetualMarketInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PerpetualMarketInfo, a, b);
    }
}
PerpetualMarketInfo.runtime = proto3;
PerpetualMarketInfo.typeName = "injective.exchange.v1beta1.PerpetualMarketInfo";
PerpetualMarketInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "next_funding_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketFunding
 */
export class PerpetualMarketFunding extends Message {
    constructor(data) {
        super();
        /**
         * cumulative_funding defines the cumulative funding of a perpetual market.
         *
         * @generated from field: string cumulative_funding = 1;
         */
        this.cumulativeFunding = "";
        /**
         * cumulative_price defines the cumulative price for the current hour up to
         * the last timestamp
         *
         * @generated from field: string cumulative_price = 2;
         */
        this.cumulativePrice = "";
        /**
         * @generated from field: int64 last_timestamp = 3;
         */
        this.lastTimestamp = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PerpetualMarketFunding().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PerpetualMarketFunding().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PerpetualMarketFunding().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PerpetualMarketFunding, a, b);
    }
}
PerpetualMarketFunding.runtime = proto3;
PerpetualMarketFunding.typeName = "injective.exchange.v1beta1.PerpetualMarketFunding";
PerpetualMarketFunding.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.DerivativeMarketSettlementInfo
 */
export class DerivativeMarketSettlementInfo extends Message {
    constructor(data) {
        super();
        /**
         * market ID.
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * settlement_price defines the settlement price
         *
         * @generated from field: string settlement_price = 2;
         */
        this.settlementPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeMarketSettlementInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeMarketSettlementInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeMarketSettlementInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeMarketSettlementInfo, a, b);
    }
}
DerivativeMarketSettlementInfo.runtime = proto3;
DerivativeMarketSettlementInfo.typeName = "injective.exchange.v1beta1.DerivativeMarketSettlementInfo";
DerivativeMarketSettlementInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.NextFundingTimestamp
 */
export class NextFundingTimestamp extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 next_timestamp = 1;
         */
        this.nextTimestamp = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new NextFundingTimestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new NextFundingTimestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new NextFundingTimestamp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(NextFundingTimestamp, a, b);
    }
}
NextFundingTimestamp.runtime = proto3;
NextFundingTimestamp.typeName = "injective.exchange.v1beta1.NextFundingTimestamp";
NextFundingTimestamp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "next_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.MidPriceAndTOB
 */
export class MidPriceAndTOB extends Message {
    constructor(data) {
        super();
        /**
         * mid price of the market
         *
         * @generated from field: string mid_price = 1;
         */
        this.midPrice = "";
        /**
         * best buy price of the market
         *
         * @generated from field: string best_buy_price = 2;
         */
        this.bestBuyPrice = "";
        /**
         * best sell price of the market
         *
         * @generated from field: string best_sell_price = 3;
         */
        this.bestSellPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MidPriceAndTOB().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MidPriceAndTOB().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MidPriceAndTOB().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MidPriceAndTOB, a, b);
    }
}
MidPriceAndTOB.runtime = proto3;
MidPriceAndTOB.typeName = "injective.exchange.v1beta1.MidPriceAndTOB";
MidPriceAndTOB.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * An object describing trade pair of two assets.
 *
 * @generated from message injective.exchange.v1beta1.SpotMarket
 */
export class SpotMarket extends Message {
    constructor(data) {
        super();
        /**
         * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
         * asset.
         *
         * @generated from field: string ticker = 1;
         */
        this.ticker = "";
        /**
         * Coin denom used for the base asset
         *
         * @generated from field: string base_denom = 2;
         */
        this.baseDenom = "";
        /**
         * Coin used for the quote asset
         *
         * @generated from field: string quote_denom = 3;
         */
        this.quoteDenom = "";
        /**
         * maker_fee_rate defines the fee percentage makers pay when trading
         *
         * @generated from field: string maker_fee_rate = 4;
         */
        this.makerFeeRate = "";
        /**
         * taker_fee_rate defines the fee percentage takers pay when trading
         *
         * @generated from field: string taker_fee_rate = 5;
         */
        this.takerFeeRate = "";
        /**
         * relayer_fee_share_rate defines the percentage of the transaction fee shared
         * with the relayer in a derivative market
         *
         * @generated from field: string relayer_fee_share_rate = 6;
         */
        this.relayerFeeShareRate = "";
        /**
         * Unique market ID.
         *
         * @generated from field: string market_id = 7;
         */
        this.marketId = "";
        /**
         * Status of the market
         *
         * @generated from field: injective.exchange.v1beta1.MarketStatus status = 8;
         */
        this.status = MarketStatus.Unspecified;
        /**
         * min_price_tick_size defines the minimum tick size that the price required
         * for orders in the market
         *
         * @generated from field: string min_price_tick_size = 9;
         */
        this.minPriceTickSize = "";
        /**
         * min_quantity_tick_size defines the minimum tick size of the quantity
         * required for orders in the market
         *
         * @generated from field: string min_quantity_tick_size = 10;
         */
        this.minQuantityTickSize = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SpotMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpotMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpotMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpotMarket, a, b);
    }
}
SpotMarket.runtime = proto3;
SpotMarket.typeName = "injective.exchange.v1beta1.SpotMarket";
SpotMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from message injective.exchange.v1beta1.Deposit
 */
export class Deposit extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string available_balance = 1;
         */
        this.availableBalance = "";
        /**
         * @generated from field: string total_balance = 2;
         */
        this.totalBalance = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Deposit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Deposit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Deposit().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Deposit, a, b);
    }
}
Deposit.runtime = proto3;
Deposit.typeName = "injective.exchange.v1beta1.Deposit";
Deposit.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "available_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "total_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountTradeNonce
 */
export class SubaccountTradeNonce extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 nonce = 1;
         */
        this.nonce = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountTradeNonce().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountTradeNonce().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountTradeNonce().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountTradeNonce, a, b);
    }
}
SubaccountTradeNonce.runtime = proto3;
SubaccountTradeNonce.typeName = "injective.exchange.v1beta1.SubaccountTradeNonce";
SubaccountTradeNonce.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.OrderInfo
 */
export class OrderInfo extends Message {
    constructor(data) {
        super();
        /**
         * bytes32 subaccount ID that created the order
         *
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * address fee_recipient address that will receive fees for the order
         *
         * @generated from field: string fee_recipient = 2;
         */
        this.feeRecipient = "";
        /**
         * price of the order
         *
         * @generated from field: string price = 3;
         */
        this.price = "";
        /**
         * quantity of the order
         *
         * @generated from field: string quantity = 4;
         */
        this.quantity = "";
        /**
         * @generated from field: string cid = 5;
         */
        this.cid = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OrderInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OrderInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OrderInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(OrderInfo, a, b);
    }
}
OrderInfo.runtime = proto3;
OrderInfo.typeName = "injective.exchange.v1beta1.OrderInfo";
OrderInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SpotOrder
 */
export class SpotOrder extends Message {
    constructor(data) {
        super();
        /**
         * market_id represents the unique ID of the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 3;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 4;
         */
        this.triggerPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SpotOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpotOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpotOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpotOrder, a, b);
    }
}
SpotOrder.runtime = proto3;
SpotOrder.typeName = "injective.exchange.v1beta1.SpotOrder";
SpotOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A valid Spot limit order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.SpotLimitOrder
 */
export class SpotLimitOrder extends Message {
    constructor(data) {
        super();
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * the amount of the quantity remaining fillable
         *
         * @generated from field: string fillable = 3;
         */
        this.fillable = "";
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 4;
         */
        this.triggerPrice = "";
        /**
         * @generated from field: bytes order_hash = 5;
         */
        this.orderHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SpotLimitOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpotLimitOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpotLimitOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpotLimitOrder, a, b);
    }
}
SpotLimitOrder.runtime = proto3;
SpotLimitOrder.typeName = "injective.exchange.v1beta1.SpotLimitOrder";
SpotLimitOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * A valid Spot market order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.SpotMarketOrder
 */
export class SpotMarketOrder extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string balance_hold = 2;
         */
        this.balanceHold = "";
        /**
         * @generated from field: bytes order_hash = 3;
         */
        this.orderHash = new Uint8Array(0);
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 4;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 5;
         */
        this.triggerPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SpotMarketOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpotMarketOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpotMarketOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpotMarketOrder, a, b);
    }
}
SpotMarketOrder.runtime = proto3;
SpotMarketOrder.typeName = "injective.exchange.v1beta1.SpotMarketOrder";
SpotMarketOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.DerivativeOrder
 */
export class DerivativeOrder extends Message {
    constructor(data) {
        super();
        /**
         * market_id represents the unique ID of the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 3;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * margin is the margin used by the limit order
         *
         * @generated from field: string margin = 4;
         */
        this.margin = "";
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 5;
         */
        this.triggerPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeOrder, a, b);
    }
}
DerivativeOrder.runtime = proto3;
DerivativeOrder.typeName = "injective.exchange.v1beta1.DerivativeOrder";
DerivativeOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderbookMetadata
 */
export class SubaccountOrderbookMetadata extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 vanilla_limit_order_count = 1;
         */
        this.vanillaLimitOrderCount = 0;
        /**
         * @generated from field: uint32 reduce_only_limit_order_count = 2;
         */
        this.reduceOnlyLimitOrderCount = 0;
        /**
         * AggregateReduceOnlyQuantity is the aggregate fillable quantity of the
         * subaccount's reduce-only limit orders in the given direction.
         *
         * @generated from field: string aggregate_reduce_only_quantity = 3;
         */
        this.aggregateReduceOnlyQuantity = "";
        /**
         * AggregateVanillaQuantity is the aggregate fillable quantity of the
         * subaccount's vanilla limit orders in the given direction.
         *
         * @generated from field: string aggregate_vanilla_quantity = 4;
         */
        this.aggregateVanillaQuantity = "";
        /**
         * @generated from field: uint32 vanilla_conditional_order_count = 5;
         */
        this.vanillaConditionalOrderCount = 0;
        /**
         * @generated from field: uint32 reduce_only_conditional_order_count = 6;
         */
        this.reduceOnlyConditionalOrderCount = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountOrderbookMetadata().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountOrderbookMetadata().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountOrderbookMetadata().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountOrderbookMetadata, a, b);
    }
}
SubaccountOrderbookMetadata.runtime = proto3;
SubaccountOrderbookMetadata.typeName = "injective.exchange.v1beta1.SubaccountOrderbookMetadata";
SubaccountOrderbookMetadata.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "vanilla_limit_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "reduce_only_limit_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "aggregate_reduce_only_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "aggregate_vanilla_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "vanilla_conditional_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "reduce_only_conditional_order_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrder
 */
export class SubaccountOrder extends Message {
    constructor(data) {
        super();
        /**
         * price of the order
         *
         * @generated from field: string price = 1;
         */
        this.price = "";
        /**
         * the amount of the quantity remaining fillable
         *
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * @generated from field: bool isReduceOnly = 3;
         */
        this.isReduceOnly = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountOrder, a, b);
    }
}
SubaccountOrder.runtime = proto3;
SubaccountOrder.typeName = "injective.exchange.v1beta1.SubaccountOrder";
SubaccountOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isReduceOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderData
 */
export class SubaccountOrderData extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes order_hash = 2;
         */
        this.orderHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountOrderData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountOrderData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountOrderData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountOrderData, a, b);
    }
}
SubaccountOrderData.runtime = proto3;
SubaccountOrderData.typeName = "injective.exchange.v1beta1.SubaccountOrderData";
SubaccountOrderData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "order", kind: "message", T: SubaccountOrder },
    { no: 2, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * A valid Derivative limit order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeLimitOrder
 */
export class DerivativeLimitOrder extends Message {
    constructor(data) {
        super();
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * margin is the margin used by the limit order
         *
         * @generated from field: string margin = 3;
         */
        this.margin = "";
        /**
         * the amount of the quantity remaining fillable
         *
         * @generated from field: string fillable = 4;
         */
        this.fillable = "";
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 5;
         */
        this.triggerPrice = "";
        /**
         * @generated from field: bytes order_hash = 6;
         */
        this.orderHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeLimitOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeLimitOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeLimitOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeLimitOrder, a, b);
    }
}
DerivativeLimitOrder.runtime = proto3;
DerivativeLimitOrder.typeName = "injective.exchange.v1beta1.DerivativeLimitOrder";
DerivativeLimitOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * A valid Derivative market order with Metadata.
 *
 * @generated from message injective.exchange.v1beta1.DerivativeMarketOrder
 */
export class DerivativeMarketOrder extends Message {
    constructor(data) {
        super();
        /**
         * order types
         *
         * @generated from field: injective.exchange.v1beta1.OrderType order_type = 2;
         */
        this.orderType = OrderType.UNSPECIFIED;
        /**
         * @generated from field: string margin = 3;
         */
        this.margin = "";
        /**
         * @generated from field: string margin_hold = 4;
         */
        this.marginHold = "";
        /**
         * trigger_price is the trigger price used by stop/take orders
         *
         * @generated from field: string trigger_price = 5;
         */
        this.triggerPrice = "";
        /**
         * @generated from field: bytes order_hash = 6;
         */
        this.orderHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeMarketOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeMarketOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeMarketOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeMarketOrder, a, b);
    }
}
DerivativeMarketOrder.runtime = proto3;
DerivativeMarketOrder.typeName = "injective.exchange.v1beta1.DerivativeMarketOrder";
DerivativeMarketOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.Position
 */
export class Position extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bool isLong = 1;
         */
        this.isLong = false;
        /**
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * @generated from field: string entry_price = 3;
         */
        this.entryPrice = "";
        /**
         * @generated from field: string margin = 4;
         */
        this.margin = "";
        /**
         * @generated from field: string cumulative_funding_entry = 5;
         */
        this.cumulativeFundingEntry = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Position().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Position().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Position().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Position, a, b);
    }
}
Position.runtime = proto3;
Position.typeName = "injective.exchange.v1beta1.Position";
Position.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "isLong", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.MarketOrderIndicator
 */
export class MarketOrderIndicator extends Message {
    constructor(data) {
        super();
        /**
         * market_id represents the unique ID of the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * @generated from field: bool isBuy = 2;
         */
        this.isBuy = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MarketOrderIndicator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MarketOrderIndicator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MarketOrderIndicator().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MarketOrderIndicator, a, b);
    }
}
MarketOrderIndicator.runtime = proto3;
MarketOrderIndicator.typeName = "injective.exchange.v1beta1.MarketOrderIndicator";
MarketOrderIndicator.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.TradeLog
 */
export class TradeLog extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string quantity = 1;
         */
        this.quantity = "";
        /**
         * @generated from field: string price = 2;
         */
        this.price = "";
        /**
         * bytes32 subaccount ID that executed the trade
         *
         * @generated from field: bytes subaccount_id = 3;
         */
        this.subaccountId = new Uint8Array(0);
        /**
         * @generated from field: string fee = 4;
         */
        this.fee = "";
        /**
         * @generated from field: bytes order_hash = 5;
         */
        this.orderHash = new Uint8Array(0);
        /**
         * @generated from field: bytes fee_recipient_address = 6;
         */
        this.feeRecipientAddress = new Uint8Array(0);
        /**
         * @generated from field: string cid = 7;
         */
        this.cid = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradeLog().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradeLog().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradeLog().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradeLog, a, b);
    }
}
TradeLog.runtime = proto3;
TradeLog.typeName = "injective.exchange.v1beta1.TradeLog";
TradeLog.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.PositionDelta
 */
export class PositionDelta extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bool is_long = 1;
         */
        this.isLong = false;
        /**
         * @generated from field: string execution_quantity = 2;
         */
        this.executionQuantity = "";
        /**
         * @generated from field: string execution_margin = 3;
         */
        this.executionMargin = "";
        /**
         * @generated from field: string execution_price = 4;
         */
        this.executionPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PositionDelta().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PositionDelta().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PositionDelta().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PositionDelta, a, b);
    }
}
PositionDelta.runtime = proto3;
PositionDelta.typeName = "injective.exchange.v1beta1.PositionDelta";
PositionDelta.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "is_long", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "execution_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "execution_margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "execution_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.DerivativeTradeLog
 */
export class DerivativeTradeLog extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes subaccount_id = 1;
         */
        this.subaccountId = new Uint8Array(0);
        /**
         * @generated from field: string payout = 3;
         */
        this.payout = "";
        /**
         * @generated from field: string fee = 4;
         */
        this.fee = "";
        /**
         * @generated from field: bytes order_hash = 5;
         */
        this.orderHash = new Uint8Array(0);
        /**
         * @generated from field: bytes fee_recipient_address = 6;
         */
        this.feeRecipientAddress = new Uint8Array(0);
        /**
         * @generated from field: string cid = 7;
         */
        this.cid = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DerivativeTradeLog().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DerivativeTradeLog().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DerivativeTradeLog().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DerivativeTradeLog, a, b);
    }
}
DerivativeTradeLog.runtime = proto3;
DerivativeTradeLog.typeName = "injective.exchange.v1beta1.DerivativeTradeLog";
DerivativeTradeLog.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "position_delta", kind: "message", T: PositionDelta },
    { no: 3, name: "payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountPosition
 */
export class SubaccountPosition extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes subaccount_id = 2;
         */
        this.subaccountId = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountPosition().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountPosition().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountPosition().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountPosition, a, b);
    }
}
SubaccountPosition.runtime = proto3;
SubaccountPosition.typeName = "injective.exchange.v1beta1.SubaccountPosition";
SubaccountPosition.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountDeposit
 */
export class SubaccountDeposit extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes subaccount_id = 1;
         */
        this.subaccountId = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountDeposit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountDeposit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountDeposit().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountDeposit, a, b);
    }
}
SubaccountDeposit.runtime = proto3;
SubaccountDeposit.typeName = "injective.exchange.v1beta1.SubaccountDeposit";
SubaccountDeposit.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "deposit", kind: "message", T: Deposit },
]);
/**
 * @generated from message injective.exchange.v1beta1.DepositUpdate
 */
export class DepositUpdate extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string denom = 1;
         */
        this.denom = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.SubaccountDeposit deposits = 2;
         */
        this.deposits = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DepositUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DepositUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DepositUpdate().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DepositUpdate, a, b);
    }
}
DepositUpdate.runtime = proto3;
DepositUpdate.typeName = "injective.exchange.v1beta1.DepositUpdate";
DepositUpdate.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deposits", kind: "message", T: SubaccountDeposit, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.PointsMultiplier
 */
export class PointsMultiplier extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string maker_points_multiplier = 1;
         */
        this.makerPointsMultiplier = "";
        /**
         * @generated from field: string taker_points_multiplier = 2;
         */
        this.takerPointsMultiplier = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PointsMultiplier().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PointsMultiplier().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PointsMultiplier().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PointsMultiplier, a, b);
    }
}
PointsMultiplier.runtime = proto3;
PointsMultiplier.typeName = "injective.exchange.v1beta1.PointsMultiplier";
PointsMultiplier.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
 */
export class TradingRewardCampaignBoostInfo extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string boosted_spot_market_ids = 1;
         */
        this.boostedSpotMarketIds = [];
        /**
         * @generated from field: repeated injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2;
         */
        this.spotMarketMultipliers = [];
        /**
         * @generated from field: repeated string boosted_derivative_market_ids = 3;
         */
        this.boostedDerivativeMarketIds = [];
        /**
         * @generated from field: repeated injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4;
         */
        this.derivativeMarketMultipliers = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradingRewardCampaignBoostInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradingRewardCampaignBoostInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradingRewardCampaignBoostInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradingRewardCampaignBoostInfo, a, b);
    }
}
TradingRewardCampaignBoostInfo.runtime = proto3;
TradingRewardCampaignBoostInfo.typeName = "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo";
TradingRewardCampaignBoostInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "boosted_spot_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "spot_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
    { no: 3, name: "boosted_derivative_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "derivative_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.CampaignRewardPool
 */
export class CampaignRewardPool extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 start_timestamp = 1;
         */
        this.startTimestamp = protoInt64.zero;
        /**
         * max_campaign_rewards are the maximum reward amounts to be disbursed at the
         * end of the campaign
         *
         * @generated from field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2;
         */
        this.maxCampaignRewards = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CampaignRewardPool().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CampaignRewardPool().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CampaignRewardPool().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CampaignRewardPool, a, b);
    }
}
CampaignRewardPool.runtime = proto3;
CampaignRewardPool.typeName = "injective.exchange.v1beta1.CampaignRewardPool";
CampaignRewardPool.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "max_campaign_rewards", kind: "message", T: Coin, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.TradingRewardCampaignInfo
 */
export class TradingRewardCampaignInfo extends Message {
    constructor(data) {
        super();
        /**
         * number of seconds of the duration of each campaign
         *
         * @generated from field: int64 campaign_duration_seconds = 1;
         */
        this.campaignDurationSeconds = protoInt64.zero;
        /**
         * the trading fee quote denoms which will be counted for the rewards
         *
         * @generated from field: repeated string quote_denoms = 2;
         */
        this.quoteDenoms = [];
        /**
         * the marketIDs which are disqualified from being rewarded
         *
         * @generated from field: repeated string disqualified_market_ids = 4;
         */
        this.disqualifiedMarketIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradingRewardCampaignInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradingRewardCampaignInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradingRewardCampaignInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradingRewardCampaignInfo, a, b);
    }
}
TradingRewardCampaignInfo.runtime = proto3;
TradingRewardCampaignInfo.typeName = "injective.exchange.v1beta1.TradingRewardCampaignInfo";
TradingRewardCampaignInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "campaign_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "trading_reward_boost_info", kind: "message", T: TradingRewardCampaignBoostInfo },
    { no: 4, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountTierInfo
 */
export class FeeDiscountTierInfo extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string maker_discount_rate = 1;
         */
        this.makerDiscountRate = "";
        /**
         * @generated from field: string taker_discount_rate = 2;
         */
        this.takerDiscountRate = "";
        /**
         * @generated from field: string staked_amount = 3;
         */
        this.stakedAmount = "";
        /**
         * @generated from field: string volume = 4;
         */
        this.volume = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new FeeDiscountTierInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new FeeDiscountTierInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new FeeDiscountTierInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(FeeDiscountTierInfo, a, b);
    }
}
FeeDiscountTierInfo.runtime = proto3;
FeeDiscountTierInfo.typeName = "injective.exchange.v1beta1.FeeDiscountTierInfo";
FeeDiscountTierInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "staked_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountSchedule
 */
export class FeeDiscountSchedule extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 bucket_count = 1;
         */
        this.bucketCount = protoInt64.zero;
        /**
         * @generated from field: int64 bucket_duration = 2;
         */
        this.bucketDuration = protoInt64.zero;
        /**
         * the trading fee quote denoms which will be counted for the fee paid
         * contribution
         *
         * @generated from field: repeated string quote_denoms = 3;
         */
        this.quoteDenoms = [];
        /**
         * the fee discount tiers
         *
         * @generated from field: repeated injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4;
         */
        this.tierInfos = [];
        /**
         * the marketIDs which are disqualified from contributing to the fee paid
         * amount
         *
         * @generated from field: repeated string disqualified_market_ids = 5;
         */
        this.disqualifiedMarketIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new FeeDiscountSchedule().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new FeeDiscountSchedule().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new FeeDiscountSchedule().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(FeeDiscountSchedule, a, b);
    }
}
FeeDiscountSchedule.runtime = proto3;
FeeDiscountSchedule.typeName = "injective.exchange.v1beta1.FeeDiscountSchedule";
FeeDiscountSchedule.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "bucket_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "tier_infos", kind: "message", T: FeeDiscountTierInfo, repeated: true },
    { no: 5, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.FeeDiscountTierTTL
 */
export class FeeDiscountTierTTL extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 tier = 1;
         */
        this.tier = protoInt64.zero;
        /**
         * @generated from field: int64 ttl_timestamp = 2;
         */
        this.ttlTimestamp = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new FeeDiscountTierTTL().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new FeeDiscountTierTTL().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new FeeDiscountTierTTL().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(FeeDiscountTierTTL, a, b);
    }
}
FeeDiscountTierTTL.runtime = proto3;
FeeDiscountTierTTL.typeName = "injective.exchange.v1beta1.FeeDiscountTierTTL";
FeeDiscountTierTTL.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ttl_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.VolumeRecord
 */
export class VolumeRecord extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string maker_volume = 1;
         */
        this.makerVolume = "";
        /**
         * @generated from field: string taker_volume = 2;
         */
        this.takerVolume = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new VolumeRecord().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new VolumeRecord().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new VolumeRecord().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(VolumeRecord, a, b);
    }
}
VolumeRecord.runtime = proto3;
VolumeRecord.typeName = "injective.exchange.v1beta1.VolumeRecord";
VolumeRecord.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.AccountRewards
 */
export class AccountRewards extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string account = 1;
         */
        this.account = "";
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin rewards = 2;
         */
        this.rewards = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AccountRewards().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AccountRewards().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AccountRewards().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AccountRewards, a, b);
    }
}
AccountRewards.runtime = proto3;
AccountRewards.typeName = "injective.exchange.v1beta1.AccountRewards";
AccountRewards.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rewards", kind: "message", T: Coin, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.TradeRecords
 */
export class TradeRecords extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TradeRecord latest_trade_records = 2;
         */
        this.latestTradeRecords = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradeRecords().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradeRecords().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradeRecords().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradeRecords, a, b);
    }
}
TradeRecords.runtime = proto3;
TradeRecords.typeName = "injective.exchange.v1beta1.TradeRecords";
TradeRecords.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "latest_trade_records", kind: "message", T: TradeRecord, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountIDs
 */
export class SubaccountIDs extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated bytes subaccount_ids = 1;
         */
        this.subaccountIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountIDs().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountIDs().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountIDs().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountIDs, a, b);
    }
}
SubaccountIDs.runtime = proto3;
SubaccountIDs.typeName = "injective.exchange.v1beta1.SubaccountIDs";
SubaccountIDs.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.TradeRecord
 */
export class TradeRecord extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 timestamp = 1;
         */
        this.timestamp = protoInt64.zero;
        /**
         * @generated from field: string price = 2;
         */
        this.price = "";
        /**
         * @generated from field: string quantity = 3;
         */
        this.quantity = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradeRecord().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradeRecord().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradeRecord().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradeRecord, a, b);
    }
}
TradeRecord.runtime = proto3;
TradeRecord.typeName = "injective.exchange.v1beta1.TradeRecord";
TradeRecord.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.Level
 */
export class Level extends Message {
    constructor(data) {
        super();
        /**
         * price
         *
         * @generated from field: string p = 1;
         */
        this.p = "";
        /**
         * quantity
         *
         * @generated from field: string q = 2;
         */
        this.q = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Level().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Level().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Level().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Level, a, b);
    }
}
Level.runtime = proto3;
Level.typeName = "injective.exchange.v1beta1.Level";
Level.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
 */
export class AggregateSubaccountVolumeRecord extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2;
         */
        this.marketVolumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AggregateSubaccountVolumeRecord().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AggregateSubaccountVolumeRecord().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AggregateSubaccountVolumeRecord().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AggregateSubaccountVolumeRecord, a, b);
    }
}
AggregateSubaccountVolumeRecord.runtime = proto3;
AggregateSubaccountVolumeRecord.typeName = "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord";
AggregateSubaccountVolumeRecord.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.AggregateAccountVolumeRecord
 */
export class AggregateAccountVolumeRecord extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string account = 1;
         */
        this.account = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.MarketVolume market_volumes = 2;
         */
        this.marketVolumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AggregateAccountVolumeRecord().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AggregateAccountVolumeRecord().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AggregateAccountVolumeRecord().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AggregateAccountVolumeRecord, a, b);
    }
}
AggregateAccountVolumeRecord.runtime = proto3;
AggregateAccountVolumeRecord.typeName = "injective.exchange.v1beta1.AggregateAccountVolumeRecord";
AggregateAccountVolumeRecord.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.MarketVolume
 */
export class MarketVolume extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MarketVolume().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MarketVolume().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MarketVolume().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MarketVolume, a, b);
    }
}
MarketVolume.runtime = proto3;
MarketVolume.typeName = "injective.exchange.v1beta1.MarketVolume";
MarketVolume.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "message", T: VolumeRecord },
]);
/**
 * @generated from message injective.exchange.v1beta1.DenomDecimals
 */
export class DenomDecimals extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string denom = 1;
         */
        this.denom = "";
        /**
         * @generated from field: uint64 decimals = 2;
         */
        this.decimals = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DenomDecimals().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DenomDecimals().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DenomDecimals().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DenomDecimals, a, b);
    }
}
DenomDecimals.runtime = proto3;
DenomDecimals.typeName = "injective.exchange.v1beta1.DenomDecimals";
DenomDecimals.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
//# sourceMappingURL=exchange_pb.js.map