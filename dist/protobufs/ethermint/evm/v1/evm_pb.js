// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ethermint/evm/v1/evm.proto (package ethermint.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
/**
 * Params defines the EVM module parameters
 *
 * @generated from message ethermint.evm.v1.Params
 */
export class Params extends Message {
    constructor(data) {
        super();
        /**
         * evm_denom represents the token denomination used to run the EVM state
         * transitions.
         *
         * @generated from field: string evm_denom = 1;
         */
        this.evmDenom = "";
        /**
         * enable_create toggles state transitions that use the vm.Create function
         *
         * @generated from field: bool enable_create = 2;
         */
        this.enableCreate = false;
        /**
         * enable_call toggles state transitions that use the vm.Call function
         *
         * @generated from field: bool enable_call = 3;
         */
        this.enableCall = false;
        /**
         * extra_eips defines the additional EIPs for the vm.Config
         *
         * @generated from field: repeated int64 extra_eips = 4;
         */
        this.extraEips = [];
        /**
         * allow_unprotected_txs defines if replay-protected (i.e non EIP155
         * signed) transactions can be executed on the state machine.
         *
         * @generated from field: bool allow_unprotected_txs = 6;
         */
        this.allowUnprotectedTxs = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Params().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Params().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Params().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Params, a, b);
    }
}
Params.runtime = proto3;
Params.typeName = "ethermint.evm.v1.Params";
Params.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "evm_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enable_create", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "enable_call", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "extra_eips", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 5, name: "chain_config", kind: "message", T: ChainConfig },
    { no: 6, name: "allow_unprotected_txs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 * instead of *big.Int.
 *
 * @generated from message ethermint.evm.v1.ChainConfig
 */
export class ChainConfig extends Message {
    constructor(data) {
        super();
        /**
         * homestead_block switch (nil no fork, 0 = already homestead)
         *
         * @generated from field: string homestead_block = 1;
         */
        this.homesteadBlock = "";
        /**
         * dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)
         *
         * @generated from field: string dao_fork_block = 2;
         */
        this.daoForkBlock = "";
        /**
         * dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork
         *
         * @generated from field: bool dao_fork_support = 3;
         */
        this.daoForkSupport = false;
        /**
         * eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
         *
         * @generated from field: string eip150_block = 4;
         */
        this.eip150Block = "";
        /**
         * eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)
         *
         * @generated from field: string eip150_hash = 5;
         */
        this.eip150Hash = "";
        /**
         * eip155_block: EIP155Block HF block
         *
         * @generated from field: string eip155_block = 6;
         */
        this.eip155Block = "";
        /**
         * eip158_block: EIP158 HF block
         *
         * @generated from field: string eip158_block = 7;
         */
        this.eip158Block = "";
        /**
         * byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)
         *
         * @generated from field: string byzantium_block = 8;
         */
        this.byzantiumBlock = "";
        /**
         * constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)
         *
         * @generated from field: string constantinople_block = 9;
         */
        this.constantinopleBlock = "";
        /**
         * petersburg_block: Petersburg switch block (nil same as Constantinople)
         *
         * @generated from field: string petersburg_block = 10;
         */
        this.petersburgBlock = "";
        /**
         * istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)
         *
         * @generated from field: string istanbul_block = 11;
         */
        this.istanbulBlock = "";
        /**
         * muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)
         *
         * @generated from field: string muir_glacier_block = 12;
         */
        this.muirGlacierBlock = "";
        /**
         * berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)
         *
         * @generated from field: string berlin_block = 13;
         */
        this.berlinBlock = "";
        /**
         * london_block: London switch block (nil = no fork, 0 = already on london)
         *
         * @generated from field: string london_block = 17;
         */
        this.londonBlock = "";
        /**
         * arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)
         *
         * @generated from field: string arrow_glacier_block = 18;
         */
        this.arrowGlacierBlock = "";
        /**
         * gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)
         *
         * @generated from field: string gray_glacier_block = 20;
         */
        this.grayGlacierBlock = "";
        /**
         * merge_netsplit_block: Virtual fork after The Merge to use as a network splitter
         *
         * @generated from field: string merge_netsplit_block = 21;
         */
        this.mergeNetsplitBlock = "";
        /**
         * shanghai_block switch block (nil = no fork, 0 = already on shanghai)
         *
         * @generated from field: string shanghai_block = 22;
         */
        this.shanghaiBlock = "";
        /**
         * cancun_block switch block (nil = no fork, 0 = already on cancun)
         *
         * @generated from field: string cancun_block = 23;
         */
        this.cancunBlock = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ChainConfig().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ChainConfig().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ChainConfig().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ChainConfig, a, b);
    }
}
ChainConfig.runtime = proto3;
ChainConfig.typeName = "ethermint.evm.v1.ChainConfig";
ChainConfig.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "homestead_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dao_fork_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dao_fork_support", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "eip150_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "eip150_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "eip155_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "eip158_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "byzantium_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "constantinople_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "petersburg_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "istanbul_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "muir_glacier_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "berlin_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "london_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "arrow_glacier_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "gray_glacier_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "merge_netsplit_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "shanghai_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "cancun_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * State represents a single Storage key value pair item.
 *
 * @generated from message ethermint.evm.v1.State
 */
export class State extends Message {
    constructor(data) {
        super();
        /**
         * key is the stored key
         *
         * @generated from field: string key = 1;
         */
        this.key = "";
        /**
         * value is the stored value for the given key
         *
         * @generated from field: string value = 2;
         */
        this.value = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new State().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new State().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new State().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(State, a, b);
    }
}
State.runtime = proto3;
State.typeName = "ethermint.evm.v1.State";
State.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * TransactionLogs define the logs generated from a transaction execution
 * with a given hash. It it used for import/export data as transactions are not
 * persisted on blockchain state after an upgrade.
 *
 * @generated from message ethermint.evm.v1.TransactionLogs
 */
export class TransactionLogs extends Message {
    constructor(data) {
        super();
        /**
         * hash of the transaction
         *
         * @generated from field: string hash = 1;
         */
        this.hash = "";
        /**
         * logs is an array of Logs for the given transaction hash
         *
         * @generated from field: repeated ethermint.evm.v1.Log logs = 2;
         */
        this.logs = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TransactionLogs().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TransactionLogs().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TransactionLogs().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TransactionLogs, a, b);
    }
}
TransactionLogs.runtime = proto3;
TransactionLogs.typeName = "ethermint.evm.v1.TransactionLogs";
TransactionLogs.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "logs", kind: "message", T: Log, repeated: true },
]);
/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 *
 * @generated from message ethermint.evm.v1.Log
 */
export class Log extends Message {
    constructor(data) {
        super();
        /**
         * address of the contract that generated the event
         *
         * @generated from field: string address = 1;
         */
        this.address = "";
        /**
         * topics is a list of topics provided by the contract.
         *
         * @generated from field: repeated string topics = 2;
         */
        this.topics = [];
        /**
         * data which is supplied by the contract, usually ABI-encoded
         *
         * @generated from field: bytes data = 3;
         */
        this.data = new Uint8Array(0);
        /**
         * block_number of the block in which the transaction was included
         *
         * @generated from field: uint64 block_number = 4;
         */
        this.blockNumber = protoInt64.zero;
        /**
         * tx_hash is the transaction hash
         *
         * @generated from field: string tx_hash = 5;
         */
        this.txHash = "";
        /**
         * tx_index of the transaction in the block
         *
         * @generated from field: uint64 tx_index = 6;
         */
        this.txIndex = protoInt64.zero;
        /**
         * block_hash of the block in which the transaction was included
         *
         * @generated from field: string block_hash = 7;
         */
        this.blockHash = "";
        /**
         * index of the log in the block
         *
         * @generated from field: uint64 index = 8;
         */
        this.index = protoInt64.zero;
        /**
         * removed is true if this log was reverted due to a chain
         * reorganisation. You must pay attention to this field if you receive logs
         * through a filter query.
         *
         * @generated from field: bool removed = 9;
         */
        this.removed = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Log().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Log().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Log().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Log, a, b);
    }
}
Log.runtime = proto3;
Log.typeName = "ethermint.evm.v1.Log";
Log.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topics", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "block_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tx_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "removed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * TxResult stores results of Tx execution.
 *
 * @generated from message ethermint.evm.v1.TxResult
 */
export class TxResult extends Message {
    constructor(data) {
        super();
        /**
         * contract_address contains the ethereum address of the created contract (if
         * any). If the state transition is an evm.Call, the contract address will be
         * empty.
         *
         * @generated from field: string contract_address = 1;
         */
        this.contractAddress = "";
        /**
         * bloom represents the bloom filter bytes
         *
         * @generated from field: bytes bloom = 2;
         */
        this.bloom = new Uint8Array(0);
        /**
         * ret defines the bytes from the execution.
         *
         * @generated from field: bytes ret = 4;
         */
        this.ret = new Uint8Array(0);
        /**
         * reverted flag is set to true when the call has been reverted
         *
         * @generated from field: bool reverted = 5;
         */
        this.reverted = false;
        /**
         * gas_used notes the amount of gas consumed while execution
         *
         * @generated from field: uint64 gas_used = 6;
         */
        this.gasUsed = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TxResult().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TxResult().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TxResult().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TxResult, a, b);
    }
}
TxResult.runtime = proto3;
TxResult.typeName = "ethermint.evm.v1.TxResult";
TxResult.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bloom", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "tx_logs", kind: "message", T: TransactionLogs },
    { no: 4, name: "ret", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "reverted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * AccessTuple is the element type of an access list.
 *
 * @generated from message ethermint.evm.v1.AccessTuple
 */
export class AccessTuple extends Message {
    constructor(data) {
        super();
        /**
         * address is a hex formatted ethereum address
         *
         * @generated from field: string address = 1;
         */
        this.address = "";
        /**
         * storage_keys are hex formatted hashes of the storage keys
         *
         * @generated from field: repeated string storage_keys = 2;
         */
        this.storageKeys = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AccessTuple().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AccessTuple().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AccessTuple().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AccessTuple, a, b);
    }
}
AccessTuple.runtime = proto3;
AccessTuple.typeName = "ethermint.evm.v1.AccessTuple";
AccessTuple.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storage_keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * TraceConfig holds extra parameters to trace functions.
 *
 * @generated from message ethermint.evm.v1.TraceConfig
 */
export class TraceConfig extends Message {
    constructor(data) {
        super();
        /**
         * tracer is a custom javascript tracer
         *
         * @generated from field: string tracer = 1;
         */
        this.tracer = "";
        /**
         * timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
         * calls
         *
         * @generated from field: string timeout = 2;
         */
        this.timeout = "";
        /**
         * reexec defines the number of blocks the tracer is willing to go back
         *
         * @generated from field: uint64 reexec = 3;
         */
        this.reexec = protoInt64.zero;
        /**
         * disable_stack switches stack capture
         *
         * @generated from field: bool disable_stack = 5;
         */
        this.disableStack = false;
        /**
         * disable_storage switches storage capture
         *
         * @generated from field: bool disable_storage = 6;
         */
        this.disableStorage = false;
        /**
         * debug can be used to print output during capture end
         *
         * @generated from field: bool debug = 8;
         */
        this.debug = false;
        /**
         * limit defines the maximum length of output, but zero means unlimited
         *
         * @generated from field: int32 limit = 9;
         */
        this.limit = 0;
        /**
         * enable_memory switches memory capture
         *
         * @generated from field: bool enable_memory = 11;
         */
        this.enableMemory = false;
        /**
         * enable_return_data switches the capture of return data
         *
         * @generated from field: bool enable_return_data = 12;
         */
        this.enableReturnData = false;
        /**
         * tracer_json_config configures the tracer using a JSON string
         *
         * @generated from field: string tracer_json_config = 13;
         */
        this.tracerJsonConfig = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TraceConfig().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TraceConfig().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TraceConfig().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TraceConfig, a, b);
    }
}
TraceConfig.runtime = proto3;
TraceConfig.typeName = "ethermint.evm.v1.TraceConfig";
TraceConfig.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "tracer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timeout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reexec", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "disable_stack", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "disable_storage", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "debug", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 10, name: "overrides", kind: "message", T: ChainConfig },
    { no: 11, name: "enable_memory", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "enable_return_data", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "tracer_json_config", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
//# sourceMappingURL=evm_pb.js.map