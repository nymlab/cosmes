// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/peggy/v1/types.proto (package injective.peggy.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
/**
 * BridgeValidator represents a validator's ETH address and its power
 *
 * @generated from message injective.peggy.v1.BridgeValidator
 */
export class BridgeValidator extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 power = 1;
         */
        this.power = protoInt64.zero;
        /**
         * @generated from field: string ethereum_address = 2;
         */
        this.ethereumAddress = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BridgeValidator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BridgeValidator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BridgeValidator().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BridgeValidator, a, b);
    }
}
BridgeValidator.runtime = proto3;
BridgeValidator.typeName = "injective.peggy.v1.BridgeValidator";
BridgeValidator.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "power", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ethereum_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * Valset is the Ethereum Bridge Multsig Set, each peggy validator also
 * maintains an ETH key to sign messages, these are used to check signatures on
 * ETH because of the significant gas savings
 *
 * @generated from message injective.peggy.v1.Valset
 */
export class Valset extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 nonce = 1;
         */
        this.nonce = protoInt64.zero;
        /**
         * @generated from field: repeated injective.peggy.v1.BridgeValidator members = 2;
         */
        this.members = [];
        /**
         * @generated from field: uint64 height = 3;
         */
        this.height = protoInt64.zero;
        /**
         * @generated from field: string reward_amount = 4;
         */
        this.rewardAmount = "";
        /**
         * the reward token in it's Ethereum hex address representation
         *
         * @generated from field: string reward_token = 5;
         */
        this.rewardToken = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Valset().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Valset().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Valset().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Valset, a, b);
    }
}
Valset.runtime = proto3;
Valset.typeName = "injective.peggy.v1.Valset";
Valset.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "members", kind: "message", T: BridgeValidator, repeated: true },
    { no: 3, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "reward_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "reward_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * LastObservedEthereumBlockHeight stores the last observed
 * Ethereum block height along with the Cosmos block height that
 * it was observed at. These two numbers can be used to project
 * outward and always produce batches with timeouts in the future
 * even if no Ethereum block height has been relayed for a long time
 *
 * @generated from message injective.peggy.v1.LastObservedEthereumBlockHeight
 */
export class LastObservedEthereumBlockHeight extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 cosmos_block_height = 1;
         */
        this.cosmosBlockHeight = protoInt64.zero;
        /**
         * @generated from field: uint64 ethereum_block_height = 2;
         */
        this.ethereumBlockHeight = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new LastObservedEthereumBlockHeight().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new LastObservedEthereumBlockHeight().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new LastObservedEthereumBlockHeight().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(LastObservedEthereumBlockHeight, a, b);
    }
}
LastObservedEthereumBlockHeight.runtime = proto3;
LastObservedEthereumBlockHeight.typeName = "injective.peggy.v1.LastObservedEthereumBlockHeight";
LastObservedEthereumBlockHeight.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "cosmos_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ethereum_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * LastClaimEvent stores last claim event details of validator.
 *
 * @generated from message injective.peggy.v1.LastClaimEvent
 */
export class LastClaimEvent extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 ethereum_event_nonce = 1;
         */
        this.ethereumEventNonce = protoInt64.zero;
        /**
         * @generated from field: uint64 ethereum_event_height = 2;
         */
        this.ethereumEventHeight = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new LastClaimEvent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new LastClaimEvent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new LastClaimEvent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(LastClaimEvent, a, b);
    }
}
LastClaimEvent.runtime = proto3;
LastClaimEvent.typeName = "injective.peggy.v1.LastClaimEvent";
LastClaimEvent.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "ethereum_event_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ethereum_event_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * This records the relationship between an ERC20 token and the denom
 * of the corresponding Cosmos originated asset
 *
 * @generated from message injective.peggy.v1.ERC20ToDenom
 */
export class ERC20ToDenom extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string erc20 = 1;
         */
        this.erc20 = "";
        /**
         * @generated from field: string denom = 2;
         */
        this.denom = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ERC20ToDenom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ERC20ToDenom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ERC20ToDenom().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ERC20ToDenom, a, b);
    }
}
ERC20ToDenom.runtime = proto3;
ERC20ToDenom.typeName = "injective.peggy.v1.ERC20ToDenom";
ERC20ToDenom.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "erc20", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
//# sourceMappingURL=types_pb.js.map