// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file tendermint/crypto/proof.proto (package tendermint.crypto, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
/**
 * @generated from message tendermint.crypto.Proof
 */
export class Proof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 total = 1;
         */
        this.total = protoInt64.zero;
        /**
         * @generated from field: int64 index = 2;
         */
        this.index = protoInt64.zero;
        /**
         * @generated from field: bytes leaf_hash = 3;
         */
        this.leafHash = new Uint8Array(0);
        /**
         * @generated from field: repeated bytes aunts = 4;
         */
        this.aunts = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Proof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Proof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Proof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Proof, a, b);
    }
}
Proof.runtime = proto3;
Proof.typeName = "tendermint.crypto.Proof";
Proof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "total", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "index", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "leaf_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "aunts", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
]);
/**
 * @generated from message tendermint.crypto.ValueOp
 */
export class ValueOp extends Message {
    constructor(data) {
        super();
        /**
         * Encoded in ProofOp.Key.
         *
         * @generated from field: bytes key = 1;
         */
        this.key = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ValueOp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ValueOp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ValueOp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ValueOp, a, b);
    }
}
ValueOp.runtime = proto3;
ValueOp.typeName = "tendermint.crypto.ValueOp";
ValueOp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "proof", kind: "message", T: Proof },
]);
/**
 * @generated from message tendermint.crypto.DominoOp
 */
export class DominoOp extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string key = 1;
         */
        this.key = "";
        /**
         * @generated from field: string input = 2;
         */
        this.input = "";
        /**
         * @generated from field: string output = 3;
         */
        this.output = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DominoOp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DominoOp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DominoOp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DominoOp, a, b);
    }
}
DominoOp.runtime = proto3;
DominoOp.typeName = "tendermint.crypto.DominoOp";
DominoOp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "output", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * ProofOp defines an operation used for calculating Merkle root
 * The data could be arbitrary format, providing nessecary data
 * for example neighbouring node hash
 *
 * @generated from message tendermint.crypto.ProofOp
 */
export class ProofOp extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string type = 1;
         */
        this.type = "";
        /**
         * @generated from field: bytes key = 2;
         */
        this.key = new Uint8Array(0);
        /**
         * @generated from field: bytes data = 3;
         */
        this.data = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ProofOp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ProofOp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ProofOp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ProofOp, a, b);
    }
}
ProofOp.runtime = proto3;
ProofOp.typeName = "tendermint.crypto.ProofOp";
ProofOp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * ProofOps is Merkle proof defined by the list of ProofOps
 *
 * @generated from message tendermint.crypto.ProofOps
 */
export class ProofOps extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated tendermint.crypto.ProofOp ops = 1;
         */
        this.ops = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ProofOps().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ProofOps().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ProofOps().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ProofOps, a, b);
    }
}
ProofOps.runtime = proto3;
ProofOps.typeName = "tendermint.crypto.ProofOps";
ProofOps.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "ops", kind: "message", T: ProofOp, repeated: true },
]);
//# sourceMappingURL=proof_pb.js.map