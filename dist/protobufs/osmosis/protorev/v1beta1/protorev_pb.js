// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/protorev/v1beta1/protorev.proto (package osmosis.protorev.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { TakerFeesTracker } from "../../poolmanager/v1beta1/genesis_pb.js";
/**
 * TokenPairArbRoutes tracks all of the hot routes for a given pair of tokens
 *
 * @generated from message osmosis.protorev.v1beta1.TokenPairArbRoutes
 */
export class TokenPairArbRoutes extends Message {
    constructor(data) {
        super();
        /**
         * Stores all of the possible hot paths for a given pair of tokens
         *
         * @generated from field: repeated osmosis.protorev.v1beta1.Route arb_routes = 1;
         */
        this.arbRoutes = [];
        /**
         * Token denomination of the first asset
         *
         * @generated from field: string token_in = 2;
         */
        this.tokenIn = "";
        /**
         * Token denomination of the second asset
         *
         * @generated from field: string token_out = 3;
         */
        this.tokenOut = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TokenPairArbRoutes().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TokenPairArbRoutes().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TokenPairArbRoutes().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TokenPairArbRoutes, a, b);
    }
}
TokenPairArbRoutes.runtime = proto3;
TokenPairArbRoutes.typeName = "osmosis.protorev.v1beta1.TokenPairArbRoutes";
TokenPairArbRoutes.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "arb_routes", kind: "message", T: Route, repeated: true },
    { no: 2, name: "token_in", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token_out", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * Route is a hot route for a given pair of tokens
 *
 * @generated from message osmosis.protorev.v1beta1.Route
 */
export class Route extends Message {
    constructor(data) {
        super();
        /**
         * The pool IDs that are traversed in the directed cyclic graph (traversed
         * left
         * -> right)
         *
         * @generated from field: repeated osmosis.protorev.v1beta1.Trade trades = 1;
         */
        this.trades = [];
        /**
         * The step size that will be used to find the optimal swap amount in the
         * binary search
         *
         * @generated from field: string step_size = 2;
         */
        this.stepSize = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Route().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Route().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Route().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Route, a, b);
    }
}
Route.runtime = proto3;
Route.typeName = "osmosis.protorev.v1beta1.Route";
Route.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trades", kind: "message", T: Trade, repeated: true },
    { no: 2, name: "step_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * Trade is a single trade in a route
 *
 * @generated from message osmosis.protorev.v1beta1.Trade
 */
export class Trade extends Message {
    constructor(data) {
        super();
        /**
         * The pool id of the pool that is traded on
         *
         * @generated from field: uint64 pool = 1;
         */
        this.pool = protoInt64.zero;
        /**
         * The denom of the token that is traded
         *
         * @generated from field: string token_in = 2;
         */
        this.tokenIn = "";
        /**
         * The denom of the token that is received
         *
         * @generated from field: string token_out = 3;
         */
        this.tokenOut = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Trade().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Trade().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Trade().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Trade, a, b);
    }
}
Trade.runtime = proto3;
Trade.typeName = "osmosis.protorev.v1beta1.Trade";
Trade.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "pool", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "token_in", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token_out", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * RouteStatistics contains the number of trades the module has executed after a
 * swap on a given route and the profits from the trades
 *
 * @generated from message osmosis.protorev.v1beta1.RouteStatistics
 */
export class RouteStatistics extends Message {
    constructor(data) {
        super();
        /**
         * profits is the total profit from all trades on this route
         *
         * @generated from field: repeated cosmos.base.v1beta1.Coin profits = 1;
         */
        this.profits = [];
        /**
         * number_of_trades is the number of trades the module has executed using this
         * route
         *
         * @generated from field: string number_of_trades = 2;
         */
        this.numberOfTrades = "";
        /**
         * route is the route that was used (pool ids along the arbitrage route)
         *
         * @generated from field: repeated uint64 route = 3;
         */
        this.route = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new RouteStatistics().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RouteStatistics().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RouteStatistics().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(RouteStatistics, a, b);
    }
}
RouteStatistics.runtime = proto3;
RouteStatistics.typeName = "osmosis.protorev.v1beta1.RouteStatistics";
RouteStatistics.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profits", kind: "message", T: Coin, repeated: true },
    { no: 2, name: "number_of_trades", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "route", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
]);
/**
 * PoolWeights contains the weights of all of the different pool types. This
 * distinction is made and necessary because the execution time ranges
 * significantly between the different pool types. Each weight roughly
 * corresponds to the amount of time (in ms) it takes to execute a swap on that
 * pool type.
 *
 * DEPRECATED: This field is deprecated and will be removed in the next
 * release. It is replaced by the `info_by_pool_type` field.
 *
 * @generated from message osmosis.protorev.v1beta1.PoolWeights
 */
export class PoolWeights extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a stableswap pool
         *
         * @generated from field: uint64 stable_weight = 1;
         */
        this.stableWeight = protoInt64.zero;
        /**
         * The weight of a balancer pool
         *
         * @generated from field: uint64 balancer_weight = 2;
         */
        this.balancerWeight = protoInt64.zero;
        /**
         * The weight of a concentrated pool
         *
         * @generated from field: uint64 concentrated_weight = 3;
         */
        this.concentratedWeight = protoInt64.zero;
        /**
         * The weight of a cosmwasm pool
         *
         * @generated from field: uint64 cosmwasm_weight = 4;
         */
        this.cosmwasmWeight = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PoolWeights().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PoolWeights().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PoolWeights().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PoolWeights, a, b);
    }
}
PoolWeights.runtime = proto3;
PoolWeights.typeName = "osmosis.protorev.v1beta1.PoolWeights";
PoolWeights.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "stable_weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "balancer_weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "concentrated_weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "cosmwasm_weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * InfoByPoolType contains information pertaining to how expensive (in terms of
 * gas and time) it is to execute a swap on a given pool type. This distinction
 * is made and necessary because the execution time ranges significantly between
 * the different pool types.
 *
 * @generated from message osmosis.protorev.v1beta1.InfoByPoolType
 */
export class InfoByPoolType extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InfoByPoolType().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InfoByPoolType().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InfoByPoolType().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InfoByPoolType, a, b);
    }
}
InfoByPoolType.runtime = proto3;
InfoByPoolType.typeName = "osmosis.protorev.v1beta1.InfoByPoolType";
InfoByPoolType.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "stable", kind: "message", T: StablePoolInfo },
    { no: 2, name: "balancer", kind: "message", T: BalancerPoolInfo },
    { no: 3, name: "concentrated", kind: "message", T: ConcentratedPoolInfo },
    { no: 4, name: "cosmwasm", kind: "message", T: CosmwasmPoolInfo },
]);
/**
 * StablePoolInfo contains meta data pertaining to a stableswap pool type.
 *
 * @generated from message osmosis.protorev.v1beta1.StablePoolInfo
 */
export class StablePoolInfo extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a stableswap pool
         *
         * @generated from field: uint64 weight = 1;
         */
        this.weight = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StablePoolInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StablePoolInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StablePoolInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StablePoolInfo, a, b);
    }
}
StablePoolInfo.runtime = proto3;
StablePoolInfo.typeName = "osmosis.protorev.v1beta1.StablePoolInfo";
StablePoolInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * BalancerPoolInfo contains meta data pertaining to a balancer pool type.
 *
 * @generated from message osmosis.protorev.v1beta1.BalancerPoolInfo
 */
export class BalancerPoolInfo extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a balancer pool
         *
         * @generated from field: uint64 weight = 1;
         */
        this.weight = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BalancerPoolInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BalancerPoolInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BalancerPoolInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BalancerPoolInfo, a, b);
    }
}
BalancerPoolInfo.runtime = proto3;
BalancerPoolInfo.typeName = "osmosis.protorev.v1beta1.BalancerPoolInfo";
BalancerPoolInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * ConcentratedPoolInfo contains meta data pertaining to a concentrated pool
 * type.
 *
 * @generated from message osmosis.protorev.v1beta1.ConcentratedPoolInfo
 */
export class ConcentratedPoolInfo extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a concentrated pool
         *
         * @generated from field: uint64 weight = 1;
         */
        this.weight = protoInt64.zero;
        /**
         * The maximum number of ticks we can move when rebalancing
         *
         * @generated from field: uint64 max_ticks_crossed = 2;
         */
        this.maxTicksCrossed = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ConcentratedPoolInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ConcentratedPoolInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ConcentratedPoolInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ConcentratedPoolInfo, a, b);
    }
}
ConcentratedPoolInfo.runtime = proto3;
ConcentratedPoolInfo.typeName = "osmosis.protorev.v1beta1.ConcentratedPoolInfo";
ConcentratedPoolInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max_ticks_crossed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * CosmwasmPoolInfo contains meta data pertaining to a cosmwasm pool type.
 *
 * @generated from message osmosis.protorev.v1beta1.CosmwasmPoolInfo
 */
export class CosmwasmPoolInfo extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a cosmwasm pool (by contract address)
         *
         * @generated from field: repeated osmosis.protorev.v1beta1.WeightMap weight_maps = 1;
         */
        this.weightMaps = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CosmwasmPoolInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CosmwasmPoolInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CosmwasmPoolInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CosmwasmPoolInfo, a, b);
    }
}
CosmwasmPoolInfo.runtime = proto3;
CosmwasmPoolInfo.typeName = "osmosis.protorev.v1beta1.CosmwasmPoolInfo";
CosmwasmPoolInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "weight_maps", kind: "message", T: WeightMap, repeated: true },
]);
/**
 * WeightMap maps a contract address to a weight. The weight of an address
 * corresponds to the amount of ms required to execute a swap on that contract.
 *
 * @generated from message osmosis.protorev.v1beta1.WeightMap
 */
export class WeightMap extends Message {
    constructor(data) {
        super();
        /**
         * The weight of a cosmwasm pool (by contract address)
         *
         * @generated from field: uint64 weight = 1;
         */
        this.weight = protoInt64.zero;
        /**
         * The contract address
         *
         * @generated from field: string contract_address = 2;
         */
        this.contractAddress = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new WeightMap().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new WeightMap().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new WeightMap().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(WeightMap, a, b);
    }
}
WeightMap.runtime = proto3;
WeightMap.typeName = "osmosis.protorev.v1beta1.WeightMap";
WeightMap.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "weight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * BaseDenom represents a single base denom that the module uses for its
 * arbitrage trades. It contains the denom name alongside the step size of the
 * binary search that is used to find the optimal swap amount
 *
 * @generated from message osmosis.protorev.v1beta1.BaseDenom
 */
export class BaseDenom extends Message {
    constructor(data) {
        super();
        /**
         * The denom i.e. name of the base denom (ex. uosmo)
         *
         * @generated from field: string denom = 1;
         */
        this.denom = "";
        /**
         * The step size of the binary search that is used to find the optimal swap
         * amount
         *
         * @generated from field: string step_size = 2;
         */
        this.stepSize = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BaseDenom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BaseDenom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BaseDenom().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BaseDenom, a, b);
    }
}
BaseDenom.runtime = proto3;
BaseDenom.typeName = "osmosis.protorev.v1beta1.BaseDenom";
BaseDenom.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "step_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * BaseDenoms represents all of the base denoms that the module uses for its
 * arbitrage trades.
 *
 * @generated from message osmosis.protorev.v1beta1.BaseDenoms
 */
export class BaseDenoms extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated osmosis.protorev.v1beta1.BaseDenom base_denoms = 1;
         */
        this.baseDenoms = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BaseDenoms().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BaseDenoms().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BaseDenoms().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BaseDenoms, a, b);
    }
}
BaseDenoms.runtime = proto3;
BaseDenoms.typeName = "osmosis.protorev.v1beta1.BaseDenoms";
BaseDenoms.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "base_denoms", kind: "message", T: BaseDenom, repeated: true },
]);
/**
 * @generated from message osmosis.protorev.v1beta1.AllProtocolRevenue
 */
export class AllProtocolRevenue extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AllProtocolRevenue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AllProtocolRevenue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AllProtocolRevenue().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AllProtocolRevenue, a, b);
    }
}
AllProtocolRevenue.runtime = proto3;
AllProtocolRevenue.typeName = "osmosis.protorev.v1beta1.AllProtocolRevenue";
AllProtocolRevenue.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "taker_fees_tracker", kind: "message", T: TakerFeesTracker },
    { no: 3, name: "cyclic_arb_tracker", kind: "message", T: CyclicArbTracker },
]);
/**
 * @generated from message osmosis.protorev.v1beta1.CyclicArbTracker
 */
export class CyclicArbTracker extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin cyclic_arb = 1;
         */
        this.cyclicArb = [];
        /**
         * @generated from field: int64 height_accounting_starts_from = 2;
         */
        this.heightAccountingStartsFrom = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CyclicArbTracker().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CyclicArbTracker().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CyclicArbTracker().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CyclicArbTracker, a, b);
    }
}
CyclicArbTracker.runtime = proto3;
CyclicArbTracker.typeName = "osmosis.protorev.v1beta1.CyclicArbTracker";
CyclicArbTracker.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "cyclic_arb", kind: "message", T: Coin, repeated: true },
    { no: 2, name: "height_accounting_starts_from", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
//# sourceMappingURL=protorev_pb.js.map