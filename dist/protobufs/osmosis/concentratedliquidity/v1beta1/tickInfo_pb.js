// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/concentratedliquidity/v1beta1/tickInfo.proto (package osmosis.concentratedliquidity.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3 } from "@bufbuild/protobuf";
import { DecCoin } from "../../../cosmos/base/v1beta1/coin_pb.js";
/**
 * @generated from message osmosis.concentratedliquidity.v1beta1.TickInfo
 */
export class TickInfo extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string liquidity_gross = 1;
         */
        this.liquidityGross = "";
        /**
         * @generated from field: string liquidity_net = 2;
         */
        this.liquidityNet = "";
        /**
         * Total spread rewards accumulated in the opposite direction that the tick
         * was last crossed. i.e. if the current tick is to the right of this tick
         * (meaning its currently a greater price), then this is the total spread
         * rewards accumulated below the tick. If the current tick is to the left of
         * this tick (meaning its currently at a lower price), then this is the total
         * spread rewards accumulated above the tick.
         *
         * Note: the way this value is used depends on the direction of spread rewards
         * we are calculating for. If we are calculating spread rewards below the
         * lower tick and the lower tick is the active tick, then this is the
         * spreadRewardGrowthGlobal - the lower tick's
         * spreadRewardGrowthOppositeDirectionOfLastTraversal. If we are calculating
         * spread rewards above the upper tick and the upper tick is the active tick,
         * then this is just the tick's
         * spreadRewardGrowthOppositeDirectionOfLastTraversal value.
         *
         * @generated from field: repeated cosmos.base.v1beta1.DecCoin spread_reward_growth_opposite_direction_of_last_traversal = 3;
         */
        this.spreadRewardGrowthOppositeDirectionOfLastTraversal = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TickInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TickInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TickInfo().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TickInfo, a, b);
    }
}
TickInfo.runtime = proto3;
TickInfo.typeName = "osmosis.concentratedliquidity.v1beta1.TickInfo";
TickInfo.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "liquidity_gross", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "liquidity_net", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "spread_reward_growth_opposite_direction_of_last_traversal", kind: "message", T: DecCoin, repeated: true },
    { no: 4, name: "uptime_trackers", kind: "message", T: UptimeTrackers },
]);
/**
 * @generated from message osmosis.concentratedliquidity.v1beta1.UptimeTrackers
 */
export class UptimeTrackers extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated osmosis.concentratedliquidity.v1beta1.UptimeTracker list = 1;
         */
        this.list = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new UptimeTrackers().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UptimeTrackers().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UptimeTrackers().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UptimeTrackers, a, b);
    }
}
UptimeTrackers.runtime = proto3;
UptimeTrackers.typeName = "osmosis.concentratedliquidity.v1beta1.UptimeTrackers";
UptimeTrackers.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: UptimeTracker, repeated: true },
]);
/**
 * @generated from message osmosis.concentratedliquidity.v1beta1.UptimeTracker
 */
export class UptimeTracker extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.base.v1beta1.DecCoin uptime_growth_outside = 1;
         */
        this.uptimeGrowthOutside = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new UptimeTracker().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UptimeTracker().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UptimeTracker().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UptimeTracker, a, b);
    }
}
UptimeTracker.runtime = proto3;
UptimeTracker.typeName = "osmosis.concentratedliquidity.v1beta1.UptimeTracker";
UptimeTracker.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "uptime_growth_outside", kind: "message", T: DecCoin, repeated: true },
]);
//# sourceMappingURL=tickInfo_pb.js.map