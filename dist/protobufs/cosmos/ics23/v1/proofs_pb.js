// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file cosmos/ics23/v1/proofs.proto (package cosmos.ics23.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3 } from "@bufbuild/protobuf";
/**
 * @generated from enum cosmos.ics23.v1.HashOp
 */
export var HashOp;
(function (HashOp) {
    /**
     * NO_HASH is the default if no data passed. Note this is an illegal argument some places.
     *
     * @generated from enum value: NO_HASH = 0;
     */
    HashOp[HashOp["NO_HASH"] = 0] = "NO_HASH";
    /**
     * @generated from enum value: SHA256 = 1;
     */
    HashOp[HashOp["SHA256"] = 1] = "SHA256";
    /**
     * @generated from enum value: SHA512 = 2;
     */
    HashOp[HashOp["SHA512"] = 2] = "SHA512";
    /**
     * @generated from enum value: KECCAK256 = 3;
     */
    HashOp[HashOp["KECCAK256"] = 3] = "KECCAK256";
    /**
     * @generated from enum value: RIPEMD160 = 4;
     */
    HashOp[HashOp["RIPEMD160"] = 4] = "RIPEMD160";
    /**
     * ripemd160(sha256(x))
     *
     * @generated from enum value: BITCOIN = 5;
     */
    HashOp[HashOp["BITCOIN"] = 5] = "BITCOIN";
    /**
     * @generated from enum value: SHA512_256 = 6;
     */
    HashOp[HashOp["SHA512_256"] = 6] = "SHA512_256";
    /**
     * @generated from enum value: BLAKE2B_512 = 7;
     */
    HashOp[HashOp["BLAKE2B_512"] = 7] = "BLAKE2B_512";
    /**
     * @generated from enum value: BLAKE2S_256 = 8;
     */
    HashOp[HashOp["BLAKE2S_256"] = 8] = "BLAKE2S_256";
    /**
     * @generated from enum value: BLAKE3 = 9;
     */
    HashOp[HashOp["BLAKE3"] = 9] = "BLAKE3";
})(HashOp || (HashOp = {}));
// Retrieve enum metadata with: proto3.getEnumType(HashOp)
proto3.util.setEnumType(HashOp, "cosmos.ics23.v1.HashOp", [
    { no: 0, name: "NO_HASH" },
    { no: 1, name: "SHA256" },
    { no: 2, name: "SHA512" },
    { no: 3, name: "KECCAK256" },
    { no: 4, name: "RIPEMD160" },
    { no: 5, name: "BITCOIN" },
    { no: 6, name: "SHA512_256" },
    { no: 7, name: "BLAKE2B_512" },
    { no: 8, name: "BLAKE2S_256" },
    { no: 9, name: "BLAKE3" },
]);
/**
 * *
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 *
 * @generated from enum cosmos.ics23.v1.LengthOp
 */
export var LengthOp;
(function (LengthOp) {
    /**
     * NO_PREFIX don't include any length info
     *
     * @generated from enum value: NO_PREFIX = 0;
     */
    LengthOp[LengthOp["NO_PREFIX"] = 0] = "NO_PREFIX";
    /**
     * VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
     *
     * @generated from enum value: VAR_PROTO = 1;
     */
    LengthOp[LengthOp["VAR_PROTO"] = 1] = "VAR_PROTO";
    /**
     * VAR_RLP uses rlp int encoding of the length
     *
     * @generated from enum value: VAR_RLP = 2;
     */
    LengthOp[LengthOp["VAR_RLP"] = 2] = "VAR_RLP";
    /**
     * FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
     *
     * @generated from enum value: FIXED32_BIG = 3;
     */
    LengthOp[LengthOp["FIXED32_BIG"] = 3] = "FIXED32_BIG";
    /**
     * FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
     *
     * @generated from enum value: FIXED32_LITTLE = 4;
     */
    LengthOp[LengthOp["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
    /**
     * FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
     *
     * @generated from enum value: FIXED64_BIG = 5;
     */
    LengthOp[LengthOp["FIXED64_BIG"] = 5] = "FIXED64_BIG";
    /**
     * FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
     *
     * @generated from enum value: FIXED64_LITTLE = 6;
     */
    LengthOp[LengthOp["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
    /**
     * REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
     *
     * @generated from enum value: REQUIRE_32_BYTES = 7;
     */
    LengthOp[LengthOp["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
    /**
     * REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
     *
     * @generated from enum value: REQUIRE_64_BYTES = 8;
     */
    LengthOp[LengthOp["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
})(LengthOp || (LengthOp = {}));
// Retrieve enum metadata with: proto3.getEnumType(LengthOp)
proto3.util.setEnumType(LengthOp, "cosmos.ics23.v1.LengthOp", [
    { no: 0, name: "NO_PREFIX" },
    { no: 1, name: "VAR_PROTO" },
    { no: 2, name: "VAR_RLP" },
    { no: 3, name: "FIXED32_BIG" },
    { no: 4, name: "FIXED32_LITTLE" },
    { no: 5, name: "FIXED64_BIG" },
    { no: 6, name: "FIXED64_LITTLE" },
    { no: 7, name: "REQUIRE_32_BYTES" },
    { no: 8, name: "REQUIRE_64_BYTES" },
]);
/**
 * *
 * ExistenceProof takes a key and a value and a set of steps to perform on it.
 * The result of peforming all these steps will provide a "root hash", which can
 * be compared to the value in a header.
 *
 * Since it is computationally infeasible to produce a hash collission for any of the used
 * cryptographic hash functions, if someone can provide a series of operations to transform
 * a given key and value into a root hash that matches some trusted root, these key and values
 * must be in the referenced merkle tree.
 *
 * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
 * which should be controlled by a spec. Eg. with lengthOp as NONE,
 * prefix = FOO, key = BAR, value = CHOICE
 * and
 * prefix = F, key = OOBAR, value = CHOICE
 * would produce the same value.
 *
 * With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
 * in the ProofSpec is valuable to prevent this mutability. And why all trees should
 * length-prefix the data before hashing it.
 *
 * @generated from message cosmos.ics23.v1.ExistenceProof
 */
export class ExistenceProof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes key = 1;
         */
        this.key = new Uint8Array(0);
        /**
         * @generated from field: bytes value = 2;
         */
        this.value = new Uint8Array(0);
        /**
         * @generated from field: repeated cosmos.ics23.v1.InnerOp path = 4;
         */
        this.path = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ExistenceProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ExistenceProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ExistenceProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ExistenceProof, a, b);
    }
}
ExistenceProof.runtime = proto3;
ExistenceProof.typeName = "cosmos.ics23.v1.ExistenceProof";
ExistenceProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "leaf", kind: "message", T: LeafOp },
    { no: 4, name: "path", kind: "message", T: InnerOp, repeated: true },
]);
/**
 *
 * NonExistenceProof takes a proof of two neighbors, one left of the desired key,
 * one right of the desired key. If both proofs are valid AND they are neighbors,
 * then there is no valid proof for the given key.
 *
 * @generated from message cosmos.ics23.v1.NonExistenceProof
 */
export class NonExistenceProof extends Message {
    constructor(data) {
        super();
        /**
         * TODO: remove this as unnecessary??? we prove a range
         *
         * @generated from field: bytes key = 1;
         */
        this.key = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new NonExistenceProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new NonExistenceProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new NonExistenceProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(NonExistenceProof, a, b);
    }
}
NonExistenceProof.runtime = proto3;
NonExistenceProof.typeName = "cosmos.ics23.v1.NonExistenceProof";
NonExistenceProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "left", kind: "message", T: ExistenceProof },
    { no: 3, name: "right", kind: "message", T: ExistenceProof },
]);
/**
 *
 * CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 *
 * @generated from message cosmos.ics23.v1.CommitmentProof
 */
export class CommitmentProof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from oneof cosmos.ics23.v1.CommitmentProof.proof
         */
        this.proof = { case: undefined };
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CommitmentProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CommitmentProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CommitmentProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CommitmentProof, a, b);
    }
}
CommitmentProof.runtime = proto3;
CommitmentProof.typeName = "cosmos.ics23.v1.CommitmentProof";
CommitmentProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "exist", kind: "message", T: ExistenceProof, oneof: "proof" },
    { no: 2, name: "nonexist", kind: "message", T: NonExistenceProof, oneof: "proof" },
    { no: 3, name: "batch", kind: "message", T: BatchProof, oneof: "proof" },
    { no: 4, name: "compressed", kind: "message", T: CompressedBatchProof, oneof: "proof" },
]);
/**
 * *
 * LeafOp represents the raw key-value data we wish to prove, and
 * must be flexible to represent the internal transformation from
 * the original key-value pairs into the basis hash, for many existing
 * merkle trees.
 *
 * key and value are passed in. So that the signature of this operation is:
 * leafOp(key, value) -> output
 *
 * To process this, first prehash the keys and values if needed (ANY means no hash in this case):
 * hkey = prehashKey(key)
 * hvalue = prehashValue(value)
 *
 * Then combine the bytes, and hash it
 * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 *
 * @generated from message cosmos.ics23.v1.LeafOp
 */
export class LeafOp extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: cosmos.ics23.v1.HashOp hash = 1;
         */
        this.hash = HashOp.NO_HASH;
        /**
         * @generated from field: cosmos.ics23.v1.HashOp prehash_key = 2;
         */
        this.prehashKey = HashOp.NO_HASH;
        /**
         * @generated from field: cosmos.ics23.v1.HashOp prehash_value = 3;
         */
        this.prehashValue = HashOp.NO_HASH;
        /**
         * @generated from field: cosmos.ics23.v1.LengthOp length = 4;
         */
        this.length = LengthOp.NO_PREFIX;
        /**
         * prefix is a fixed bytes that may optionally be included at the beginning to differentiate
         * a leaf node from an inner node.
         *
         * @generated from field: bytes prefix = 5;
         */
        this.prefix = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new LeafOp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new LeafOp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new LeafOp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(LeafOp, a, b);
    }
}
LeafOp.runtime = proto3;
LeafOp.typeName = "cosmos.ics23.v1.LeafOp";
LeafOp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "enum", T: proto3.getEnumType(HashOp) },
    { no: 2, name: "prehash_key", kind: "enum", T: proto3.getEnumType(HashOp) },
    { no: 3, name: "prehash_value", kind: "enum", T: proto3.getEnumType(HashOp) },
    { no: 4, name: "length", kind: "enum", T: proto3.getEnumType(LengthOp) },
    { no: 5, name: "prefix", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * *
 * InnerOp represents a merkle-proof step that is not a leaf.
 * It represents concatenating two children and hashing them to provide the next result.
 *
 * The result of the previous step is passed in, so the signature of this op is:
 * innerOp(child) -> output
 *
 * The result of applying InnerOp should be:
 * output = op.hash(op.prefix || child || op.suffix)
 *
 * where the || operator is concatenation of binary data,
 * and child is the result of hashing all the tree below this step.
 *
 * Any special data, like prepending child with the length, or prepending the entire operation with
 * some value to differentiate from leaf nodes, should be included in prefix and suffix.
 * If either of prefix or suffix is empty, we just treat it as an empty string
 *
 * @generated from message cosmos.ics23.v1.InnerOp
 */
export class InnerOp extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: cosmos.ics23.v1.HashOp hash = 1;
         */
        this.hash = HashOp.NO_HASH;
        /**
         * @generated from field: bytes prefix = 2;
         */
        this.prefix = new Uint8Array(0);
        /**
         * @generated from field: bytes suffix = 3;
         */
        this.suffix = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InnerOp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InnerOp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InnerOp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InnerOp, a, b);
    }
}
InnerOp.runtime = proto3;
InnerOp.typeName = "cosmos.ics23.v1.InnerOp";
InnerOp.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "enum", T: proto3.getEnumType(HashOp) },
    { no: 2, name: "prefix", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "suffix", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * *
 * ProofSpec defines what the expected parameters are for a given proof type.
 * This can be stored in the client and used to validate any incoming proofs.
 *
 * verify(ProofSpec, Proof) -> Proof | Error
 *
 * As demonstrated in tests, if we don't fix the algorithm used to calculate the
 * LeafHash for a given tree, there are many possible key-value pairs that can
 * generate a given hash (by interpretting the preimage differently).
 * We need this for proper security, requires client knows a priori what
 * tree format server uses. But not in code, rather a configuration object.
 *
 * @generated from message cosmos.ics23.v1.ProofSpec
 */
export class ProofSpec extends Message {
    constructor(data) {
        super();
        /**
         * max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
         *
         * @generated from field: int32 max_depth = 3;
         */
        this.maxDepth = 0;
        /**
         * min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
         *
         * @generated from field: int32 min_depth = 4;
         */
        this.minDepth = 0;
        /**
         * prehash_key_before_comparison is a flag that indicates whether to use the
         * prehash_key specified by LeafOp to compare lexical ordering of keys for
         * non-existence proofs.
         *
         * @generated from field: bool prehash_key_before_comparison = 5;
         */
        this.prehashKeyBeforeComparison = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ProofSpec().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ProofSpec().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ProofSpec().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ProofSpec, a, b);
    }
}
ProofSpec.runtime = proto3;
ProofSpec.typeName = "cosmos.ics23.v1.ProofSpec";
ProofSpec.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf_spec", kind: "message", T: LeafOp },
    { no: 2, name: "inner_spec", kind: "message", T: InnerSpec },
    { no: 3, name: "max_depth", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "min_depth", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "prehash_key_before_comparison", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 *
 * InnerSpec contains all store-specific structure info to determine if two proofs from a
 * given store are neighbors.
 *
 * This enables:
 *
 * isLeftMost(spec: InnerSpec, op: InnerOp)
 * isRightMost(spec: InnerSpec, op: InnerOp)
 * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 *
 * @generated from message cosmos.ics23.v1.InnerSpec
 */
export class InnerSpec extends Message {
    constructor(data) {
        super();
        /**
         * Child order is the ordering of the children node, must count from 0
         * iavl tree is [0, 1] (left then right)
         * merk is [0, 2, 1] (left, right, here)
         *
         * @generated from field: repeated int32 child_order = 1;
         */
        this.childOrder = [];
        /**
         * @generated from field: int32 child_size = 2;
         */
        this.childSize = 0;
        /**
         * @generated from field: int32 min_prefix_length = 3;
         */
        this.minPrefixLength = 0;
        /**
         * @generated from field: int32 max_prefix_length = 4;
         */
        this.maxPrefixLength = 0;
        /**
         * empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
         *
         * @generated from field: bytes empty_child = 5;
         */
        this.emptyChild = new Uint8Array(0);
        /**
         * hash is the algorithm that must be used for each InnerOp
         *
         * @generated from field: cosmos.ics23.v1.HashOp hash = 6;
         */
        this.hash = HashOp.NO_HASH;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InnerSpec().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InnerSpec().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InnerSpec().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InnerSpec, a, b);
    }
}
InnerSpec.runtime = proto3;
InnerSpec.typeName = "cosmos.ics23.v1.InnerSpec";
InnerSpec.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "child_order", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 2, name: "child_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "min_prefix_length", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "max_prefix_length", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "empty_child", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "hash", kind: "enum", T: proto3.getEnumType(HashOp) },
]);
/**
 *
 * BatchProof is a group of multiple proof types than can be compressed
 *
 * @generated from message cosmos.ics23.v1.BatchProof
 */
export class BatchProof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.ics23.v1.BatchEntry entries = 1;
         */
        this.entries = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BatchProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BatchProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BatchProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BatchProof, a, b);
    }
}
BatchProof.runtime = proto3;
BatchProof.typeName = "cosmos.ics23.v1.BatchProof";
BatchProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: BatchEntry, repeated: true },
]);
/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from message cosmos.ics23.v1.BatchEntry
 */
export class BatchEntry extends Message {
    constructor(data) {
        super();
        /**
         * @generated from oneof cosmos.ics23.v1.BatchEntry.proof
         */
        this.proof = { case: undefined };
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BatchEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BatchEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BatchEntry().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BatchEntry, a, b);
    }
}
BatchEntry.runtime = proto3;
BatchEntry.typeName = "cosmos.ics23.v1.BatchEntry";
BatchEntry.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "exist", kind: "message", T: ExistenceProof, oneof: "proof" },
    { no: 2, name: "nonexist", kind: "message", T: NonExistenceProof, oneof: "proof" },
]);
/**
 * @generated from message cosmos.ics23.v1.CompressedBatchProof
 */
export class CompressedBatchProof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.ics23.v1.CompressedBatchEntry entries = 1;
         */
        this.entries = [];
        /**
         * @generated from field: repeated cosmos.ics23.v1.InnerOp lookup_inners = 2;
         */
        this.lookupInners = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CompressedBatchProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CompressedBatchProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CompressedBatchProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CompressedBatchProof, a, b);
    }
}
CompressedBatchProof.runtime = proto3;
CompressedBatchProof.typeName = "cosmos.ics23.v1.CompressedBatchProof";
CompressedBatchProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: CompressedBatchEntry, repeated: true },
    { no: 2, name: "lookup_inners", kind: "message", T: InnerOp, repeated: true },
]);
/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from message cosmos.ics23.v1.CompressedBatchEntry
 */
export class CompressedBatchEntry extends Message {
    constructor(data) {
        super();
        /**
         * @generated from oneof cosmos.ics23.v1.CompressedBatchEntry.proof
         */
        this.proof = { case: undefined };
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CompressedBatchEntry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CompressedBatchEntry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CompressedBatchEntry().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CompressedBatchEntry, a, b);
    }
}
CompressedBatchEntry.runtime = proto3;
CompressedBatchEntry.typeName = "cosmos.ics23.v1.CompressedBatchEntry";
CompressedBatchEntry.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "exist", kind: "message", T: CompressedExistenceProof, oneof: "proof" },
    { no: 2, name: "nonexist", kind: "message", T: CompressedNonExistenceProof, oneof: "proof" },
]);
/**
 * @generated from message cosmos.ics23.v1.CompressedExistenceProof
 */
export class CompressedExistenceProof extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes key = 1;
         */
        this.key = new Uint8Array(0);
        /**
         * @generated from field: bytes value = 2;
         */
        this.value = new Uint8Array(0);
        /**
         * these are indexes into the lookup_inners table in CompressedBatchProof
         *
         * @generated from field: repeated int32 path = 4;
         */
        this.path = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CompressedExistenceProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CompressedExistenceProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CompressedExistenceProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CompressedExistenceProof, a, b);
    }
}
CompressedExistenceProof.runtime = proto3;
CompressedExistenceProof.typeName = "cosmos.ics23.v1.CompressedExistenceProof";
CompressedExistenceProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "leaf", kind: "message", T: LeafOp },
    { no: 4, name: "path", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
]);
/**
 * @generated from message cosmos.ics23.v1.CompressedNonExistenceProof
 */
export class CompressedNonExistenceProof extends Message {
    constructor(data) {
        super();
        /**
         * TODO: remove this as unnecessary??? we prove a range
         *
         * @generated from field: bytes key = 1;
         */
        this.key = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CompressedNonExistenceProof().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CompressedNonExistenceProof().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CompressedNonExistenceProof().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CompressedNonExistenceProof, a, b);
    }
}
CompressedNonExistenceProof.runtime = proto3;
CompressedNonExistenceProof.typeName = "cosmos.ics23.v1.CompressedNonExistenceProof";
CompressedNonExistenceProof.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "left", kind: "message", T: CompressedExistenceProof },
    { no: 3, name: "right", kind: "message", T: CompressedExistenceProof },
]);
//# sourceMappingURL=proofs_pb.js.map