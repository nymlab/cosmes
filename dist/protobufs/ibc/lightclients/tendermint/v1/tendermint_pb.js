// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/lightclients/tendermint/v1/tendermint.proto (package ibc.lightclients.tendermint.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Height } from "../../../core/client/v1/client_pb.js";
import { ProofSpec } from "../../../../cosmos/ics23/v1/proofs_pb.js";
import { MerkleRoot } from "../../../core/commitment/v1/commitment_pb.js";
import { SignedHeader } from "../../../../tendermint/types/types_pb.js";
import { ValidatorSet } from "../../../../tendermint/types/validator_pb.js";
/**
 * ClientState from Tendermint tracks the current validator set, latest height,
 * and a possible frozen height.
 *
 * @generated from message ibc.lightclients.tendermint.v1.ClientState
 */
export class ClientState extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string chain_id = 1;
         */
        this.chainId = "";
        /**
         * Proof specifications used in verifying counterparty state
         *
         * @generated from field: repeated cosmos.ics23.v1.ProofSpec proof_specs = 8;
         */
        this.proofSpecs = [];
        /**
         * Path at which next upgraded client will be committed.
         * Each element corresponds to the key for a single CommitmentProof in the
         * chained proof. NOTE: ClientState must stored under
         * `{upgradePath}/{upgradeHeight}/clientState` ConsensusState must be stored
         * under `{upgradepath}/{upgradeHeight}/consensusState` For SDK chains using
         * the default upgrade module, upgrade_path should be []string{"upgrade",
         * "upgradedIBCState"}`
         *
         * @generated from field: repeated string upgrade_path = 9;
         */
        this.upgradePath = [];
        /**
         * allow_update_after_expiry is deprecated
         *
         * @generated from field: bool allow_update_after_expiry = 10 [deprecated = true];
         * @deprecated
         */
        this.allowUpdateAfterExpiry = false;
        /**
         * allow_update_after_misbehaviour is deprecated
         *
         * @generated from field: bool allow_update_after_misbehaviour = 11 [deprecated = true];
         * @deprecated
         */
        this.allowUpdateAfterMisbehaviour = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ClientState().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClientState().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClientState().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ClientState, a, b);
    }
}
ClientState.runtime = proto3;
ClientState.typeName = "ibc.lightclients.tendermint.v1.ClientState";
ClientState.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trust_level", kind: "message", T: Fraction },
    { no: 3, name: "trusting_period", kind: "message", T: Duration },
    { no: 4, name: "unbonding_period", kind: "message", T: Duration },
    { no: 5, name: "max_clock_drift", kind: "message", T: Duration },
    { no: 6, name: "frozen_height", kind: "message", T: Height },
    { no: 7, name: "latest_height", kind: "message", T: Height },
    { no: 8, name: "proof_specs", kind: "message", T: ProofSpec, repeated: true },
    { no: 9, name: "upgrade_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "allow_update_after_expiry", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "allow_update_after_misbehaviour", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * ConsensusState defines the consensus state from Tendermint.
 *
 * @generated from message ibc.lightclients.tendermint.v1.ConsensusState
 */
export class ConsensusState extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bytes next_validators_hash = 3;
         */
        this.nextValidatorsHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ConsensusState().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ConsensusState().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ConsensusState().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ConsensusState, a, b);
    }
}
ConsensusState.runtime = proto3;
ConsensusState.typeName = "ibc.lightclients.tendermint.v1.ConsensusState";
ConsensusState.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "root", kind: "message", T: MerkleRoot },
    { no: 3, name: "next_validators_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
]);
/**
 * Misbehaviour is a wrapper over two conflicting Headers
 * that implements Misbehaviour interface expected by ICS-02
 *
 * @generated from message ibc.lightclients.tendermint.v1.Misbehaviour
 */
export class Misbehaviour extends Message {
    constructor(data) {
        super();
        /**
         * ClientID is deprecated
         *
         * @generated from field: string client_id = 1 [deprecated = true];
         * @deprecated
         */
        this.clientId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Misbehaviour().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Misbehaviour().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Misbehaviour().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Misbehaviour, a, b);
    }
}
Misbehaviour.runtime = proto3;
Misbehaviour.typeName = "ibc.lightclients.tendermint.v1.Misbehaviour";
Misbehaviour.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "header_1", kind: "message", T: Header },
    { no: 3, name: "header_2", kind: "message", T: Header },
]);
/**
 * Header defines the Tendermint client consensus Header.
 * It encapsulates all the information necessary to update from a trusted
 * Tendermint ConsensusState. The inclusion of TrustedHeight and
 * TrustedValidators allows this update to process correctly, so long as the
 * ConsensusState for the TrustedHeight exists, this removes race conditions
 * among relayers The SignedHeader and ValidatorSet are the new untrusted update
 * fields for the client. The TrustedHeight is the height of a stored
 * ConsensusState on the client that will be used to verify the new untrusted
 * header. The Trusted ConsensusState must be within the unbonding period of
 * current time in order to correctly verify, and the TrustedValidators must
 * hash to TrustedConsensusState.NextValidatorsHash since that is the last
 * trusted validator set at the TrustedHeight.
 *
 * @generated from message ibc.lightclients.tendermint.v1.Header
 */
export class Header extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Header().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Header().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Header().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Header, a, b);
    }
}
Header.runtime = proto3;
Header.typeName = "ibc.lightclients.tendermint.v1.Header";
Header.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "signed_header", kind: "message", T: SignedHeader },
    { no: 2, name: "validator_set", kind: "message", T: ValidatorSet },
    { no: 3, name: "trusted_height", kind: "message", T: Height },
    { no: 4, name: "trusted_validators", kind: "message", T: ValidatorSet },
]);
/**
 * Fraction defines the protobuf message type for tmmath.Fraction that only
 * supports positive values.
 *
 * @generated from message ibc.lightclients.tendermint.v1.Fraction
 */
export class Fraction extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 numerator = 1;
         */
        this.numerator = protoInt64.zero;
        /**
         * @generated from field: uint64 denominator = 2;
         */
        this.denominator = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Fraction().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Fraction().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Fraction().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Fraction, a, b);
    }
}
Fraction.runtime = proto3;
Fraction.typeName = "ibc.lightclients.tendermint.v1.Fraction";
Fraction.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "numerator", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "denominator", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
//# sourceMappingURL=tendermint_pb.js.map