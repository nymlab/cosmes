// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file cosmwasm/wasm/v1/authz.proto (package cosmwasm.wasm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AccessConfig } from "./types_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
/**
 * StoreCodeAuthorization defines authorization for wasm code upload.
 * Since: wasmd 0.42
 *
 * @generated from message cosmwasm.wasm.v1.StoreCodeAuthorization
 */
export class StoreCodeAuthorization extends Message {
    constructor(data) {
        super();
        /**
         * Grants for code upload
         *
         * @generated from field: repeated cosmwasm.wasm.v1.CodeGrant grants = 1;
         */
        this.grants = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new StoreCodeAuthorization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StoreCodeAuthorization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StoreCodeAuthorization().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StoreCodeAuthorization, a, b);
    }
}
StoreCodeAuthorization.runtime = proto3;
StoreCodeAuthorization.typeName = "cosmwasm.wasm.v1.StoreCodeAuthorization";
StoreCodeAuthorization.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "grants", kind: "message", T: CodeGrant, repeated: true },
]);
/**
 * ContractExecutionAuthorization defines authorization for wasm execute.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.ContractExecutionAuthorization
 */
export class ContractExecutionAuthorization extends Message {
    constructor(data) {
        super();
        /**
         * Grants for contract executions
         *
         * @generated from field: repeated cosmwasm.wasm.v1.ContractGrant grants = 1;
         */
        this.grants = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ContractExecutionAuthorization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ContractExecutionAuthorization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ContractExecutionAuthorization().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ContractExecutionAuthorization, a, b);
    }
}
ContractExecutionAuthorization.runtime = proto3;
ContractExecutionAuthorization.typeName = "cosmwasm.wasm.v1.ContractExecutionAuthorization";
ContractExecutionAuthorization.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "grants", kind: "message", T: ContractGrant, repeated: true },
]);
/**
 * ContractMigrationAuthorization defines authorization for wasm contract
 * migration. Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.ContractMigrationAuthorization
 */
export class ContractMigrationAuthorization extends Message {
    constructor(data) {
        super();
        /**
         * Grants for contract migrations
         *
         * @generated from field: repeated cosmwasm.wasm.v1.ContractGrant grants = 1;
         */
        this.grants = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ContractMigrationAuthorization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ContractMigrationAuthorization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ContractMigrationAuthorization().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ContractMigrationAuthorization, a, b);
    }
}
ContractMigrationAuthorization.runtime = proto3;
ContractMigrationAuthorization.typeName = "cosmwasm.wasm.v1.ContractMigrationAuthorization";
ContractMigrationAuthorization.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "grants", kind: "message", T: ContractGrant, repeated: true },
]);
/**
 * CodeGrant a granted permission for a single code
 *
 * @generated from message cosmwasm.wasm.v1.CodeGrant
 */
export class CodeGrant extends Message {
    constructor(data) {
        super();
        /**
         * CodeHash is the unique identifier created by wasmvm
         * Wildcard "*" is used to specify any kind of grant.
         *
         * @generated from field: bytes code_hash = 1;
         */
        this.codeHash = new Uint8Array(0);
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CodeGrant().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CodeGrant().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CodeGrant().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CodeGrant, a, b);
    }
}
CodeGrant.runtime = proto3;
CodeGrant.typeName = "cosmwasm.wasm.v1.CodeGrant";
CodeGrant.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "code_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "instantiate_permission", kind: "message", T: AccessConfig },
]);
/**
 * ContractGrant a granted permission for a single contract
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.ContractGrant
 */
export class ContractGrant extends Message {
    constructor(data) {
        super();
        /**
         * Contract is the bech32 address of the smart contract
         *
         * @generated from field: string contract = 1;
         */
        this.contract = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ContractGrant().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ContractGrant().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ContractGrant().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ContractGrant, a, b);
    }
}
ContractGrant.runtime = proto3;
ContractGrant.typeName = "cosmwasm.wasm.v1.ContractGrant";
ContractGrant.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "contract", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "message", T: Any },
    { no: 3, name: "filter", kind: "message", T: Any },
]);
/**
 * MaxCallsLimit limited number of calls to the contract. No funds transferable.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.MaxCallsLimit
 */
export class MaxCallsLimit extends Message {
    constructor(data) {
        super();
        /**
         * Remaining number that is decremented on each execution
         *
         * @generated from field: uint64 remaining = 1;
         */
        this.remaining = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MaxCallsLimit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MaxCallsLimit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MaxCallsLimit().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MaxCallsLimit, a, b);
    }
}
MaxCallsLimit.runtime = proto3;
MaxCallsLimit.typeName = "cosmwasm.wasm.v1.MaxCallsLimit";
MaxCallsLimit.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "remaining", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * MaxFundsLimit defines the maximal amounts that can be sent to the contract.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.MaxFundsLimit
 */
export class MaxFundsLimit extends Message {
    constructor(data) {
        super();
        /**
         * Amounts is the maximal amount of tokens transferable to the contract.
         *
         * @generated from field: repeated cosmos.base.v1beta1.Coin amounts = 1;
         */
        this.amounts = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MaxFundsLimit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MaxFundsLimit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MaxFundsLimit().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MaxFundsLimit, a, b);
    }
}
MaxFundsLimit.runtime = proto3;
MaxFundsLimit.typeName = "cosmwasm.wasm.v1.MaxFundsLimit";
MaxFundsLimit.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "amounts", kind: "message", T: Coin, repeated: true },
]);
/**
 * CombinedLimit defines the maximal amounts that can be sent to a contract and
 * the maximal number of calls executable. Both need to remain >0 to be valid.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.CombinedLimit
 */
export class CombinedLimit extends Message {
    constructor(data) {
        super();
        /**
         * Remaining number that is decremented on each execution
         *
         * @generated from field: uint64 calls_remaining = 1;
         */
        this.callsRemaining = protoInt64.zero;
        /**
         * Amounts is the maximal amount of tokens transferable to the contract.
         *
         * @generated from field: repeated cosmos.base.v1beta1.Coin amounts = 2;
         */
        this.amounts = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new CombinedLimit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CombinedLimit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CombinedLimit().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CombinedLimit, a, b);
    }
}
CombinedLimit.runtime = proto3;
CombinedLimit.typeName = "cosmwasm.wasm.v1.CombinedLimit";
CombinedLimit.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "calls_remaining", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "amounts", kind: "message", T: Coin, repeated: true },
]);
/**
 * AllowAllMessagesFilter is a wildcard to allow any type of contract payload
 * message.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.AllowAllMessagesFilter
 */
export class AllowAllMessagesFilter extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AllowAllMessagesFilter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AllowAllMessagesFilter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AllowAllMessagesFilter().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AllowAllMessagesFilter, a, b);
    }
}
AllowAllMessagesFilter.runtime = proto3;
AllowAllMessagesFilter.typeName = "cosmwasm.wasm.v1.AllowAllMessagesFilter";
AllowAllMessagesFilter.fields = proto3.util.newFieldList(() => []);
/**
 * AcceptedMessageKeysFilter accept only the specific contract message keys in
 * the json object to be executed.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.AcceptedMessageKeysFilter
 */
export class AcceptedMessageKeysFilter extends Message {
    constructor(data) {
        super();
        /**
         * Messages is the list of unique keys
         *
         * @generated from field: repeated string keys = 1;
         */
        this.keys = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AcceptedMessageKeysFilter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AcceptedMessageKeysFilter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AcceptedMessageKeysFilter().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AcceptedMessageKeysFilter, a, b);
    }
}
AcceptedMessageKeysFilter.runtime = proto3;
AcceptedMessageKeysFilter.typeName = "cosmwasm.wasm.v1.AcceptedMessageKeysFilter";
AcceptedMessageKeysFilter.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * AcceptedMessagesFilter accept only the specific raw contract messages to be
 * executed.
 * Since: wasmd 0.30
 *
 * @generated from message cosmwasm.wasm.v1.AcceptedMessagesFilter
 */
export class AcceptedMessagesFilter extends Message {
    constructor(data) {
        super();
        /**
         * Messages is the list of raw contract messages
         *
         * @generated from field: repeated bytes messages = 1;
         */
        this.messages = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AcceptedMessagesFilter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AcceptedMessagesFilter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AcceptedMessagesFilter().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AcceptedMessagesFilter, a, b);
    }
}
AcceptedMessagesFilter.runtime = proto3;
AcceptedMessagesFilter.typeName = "cosmwasm.wasm.v1.AcceptedMessagesFilter";
AcceptedMessagesFilter.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "messages", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
]);
//# sourceMappingURL=authz_pb.js.map