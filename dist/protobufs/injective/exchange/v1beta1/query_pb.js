// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/query.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AggregateAccountVolumeRecord, BinaryOptionsMarket, CampaignRewardPool, DenomDecimals, Deposit, DerivativeMarket, ExpiryFuturesMarketInfo, FeeDiscountSchedule, FeeDiscountTierInfo, FeeDiscountTierTTL, Level, MarketVolume, MidPriceAndTOB, Params, PerpetualMarketFunding, PerpetualMarketInfo, Position, SpotMarket, SubaccountOrderbookMetadata, SubaccountOrderData, TradeRecord, TradeRecords, TradingRewardCampaignInfo, VolumeRecord } from "./exchange_pb.js";
import { Balance, DerivativePosition, GenesisState } from "./genesis_pb.js";
import { MetadataStatistics } from "../../oracle/v1beta1/oracle_pb.js";
/**
 * @generated from enum injective.exchange.v1beta1.OrderSide
 */
export var OrderSide;
(function (OrderSide) {
    /**
     * will return both
     *
     * @generated from enum value: Side_Unspecified = 0;
     */
    OrderSide[OrderSide["Side_Unspecified"] = 0] = "Side_Unspecified";
    /**
     * @generated from enum value: Buy = 1;
     */
    OrderSide[OrderSide["Buy"] = 1] = "Buy";
    /**
     * @generated from enum value: Sell = 2;
     */
    OrderSide[OrderSide["Sell"] = 2] = "Sell";
})(OrderSide || (OrderSide = {}));
// Retrieve enum metadata with: proto3.getEnumType(OrderSide)
proto3.util.setEnumType(OrderSide, "injective.exchange.v1beta1.OrderSide", [
    { no: 0, name: "Side_Unspecified" },
    { no: 1, name: "Buy" },
    { no: 2, name: "Sell" },
]);
/**
 * CancellationStrategy is the list of cancellation strategies.
 *
 * @generated from enum injective.exchange.v1beta1.CancellationStrategy
 */
export var CancellationStrategy;
(function (CancellationStrategy) {
    /**
     * just cancelling in random order in most efficient way
     *
     * @generated from enum value: UnspecifiedOrder = 0;
     */
    CancellationStrategy[CancellationStrategy["UnspecifiedOrder"] = 0] = "UnspecifiedOrder";
    /**
     * e.g. for buy orders from lowest to highest price
     *
     * @generated from enum value: FromWorstToBest = 1;
     */
    CancellationStrategy[CancellationStrategy["FromWorstToBest"] = 1] = "FromWorstToBest";
    /**
     * e.g. for buy orders from higest to lowest price
     *
     * @generated from enum value: FromBestToWorst = 2;
     */
    CancellationStrategy[CancellationStrategy["FromBestToWorst"] = 2] = "FromBestToWorst";
})(CancellationStrategy || (CancellationStrategy = {}));
// Retrieve enum metadata with: proto3.getEnumType(CancellationStrategy)
proto3.util.setEnumType(CancellationStrategy, "injective.exchange.v1beta1.CancellationStrategy", [
    { no: 0, name: "UnspecifiedOrder" },
    { no: 1, name: "FromWorstToBest" },
    { no: 2, name: "FromBestToWorst" },
]);
/**
 * @generated from message injective.exchange.v1beta1.Subaccount
 */
export class Subaccount extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string trader = 1;
         */
        this.trader = "";
        /**
         * @generated from field: uint32 subaccount_nonce = 2;
         */
        this.subaccountNonce = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Subaccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Subaccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Subaccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Subaccount, a, b);
    }
}
Subaccount.runtime = proto3;
Subaccount.typeName = "injective.exchange.v1beta1.Subaccount";
Subaccount.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrdersRequest
 */
export class QuerySubaccountOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string market_id = 2;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountOrdersRequest, a, b);
    }
}
QuerySubaccountOrdersRequest.runtime = proto3;
QuerySubaccountOrdersRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountOrdersRequest";
QuerySubaccountOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrdersResponse
 */
export class QuerySubaccountOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderData buy_orders = 1;
         */
        this.buyOrders = [];
        /**
         * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderData sell_orders = 2;
         */
        this.sellOrders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountOrdersResponse, a, b);
    }
}
QuerySubaccountOrdersResponse.runtime = proto3;
QuerySubaccountOrdersResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountOrdersResponse";
QuerySubaccountOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "buy_orders", kind: "message", T: SubaccountOrderData, repeated: true },
    { no: 2, name: "sell_orders", kind: "message", T: SubaccountOrderData, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket
 */
export class SubaccountOrderbookMetadataWithMarket extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 2;
         */
        this.marketId = "";
        /**
         * @generated from field: bool isBuy = 3;
         */
        this.isBuy = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SubaccountOrderbookMetadataWithMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SubaccountOrderbookMetadataWithMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SubaccountOrderbookMetadataWithMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SubaccountOrderbookMetadataWithMarket, a, b);
    }
}
SubaccountOrderbookMetadataWithMarket.runtime = proto3;
SubaccountOrderbookMetadataWithMarket.typeName = "injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket";
SubaccountOrderbookMetadataWithMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: SubaccountOrderbookMetadata },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * QueryExchangeParamsRequest is the request type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeParamsRequest
 */
export class QueryExchangeParamsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExchangeParamsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExchangeParamsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExchangeParamsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExchangeParamsRequest, a, b);
    }
}
QueryExchangeParamsRequest.runtime = proto3;
QueryExchangeParamsRequest.typeName = "injective.exchange.v1beta1.QueryExchangeParamsRequest";
QueryExchangeParamsRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryExchangeParamsRequest is the response type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeParamsResponse
 */
export class QueryExchangeParamsResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExchangeParamsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExchangeParamsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExchangeParamsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExchangeParamsResponse, a, b);
    }
}
QueryExchangeParamsResponse.runtime = proto3;
QueryExchangeParamsResponse.typeName = "injective.exchange.v1beta1.QueryExchangeParamsResponse";
QueryExchangeParamsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
]);
/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositsRequest
 */
export class QuerySubaccountDepositsRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountDepositsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountDepositsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountDepositsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountDepositsRequest, a, b);
    }
}
QuerySubaccountDepositsRequest.runtime = proto3;
QuerySubaccountDepositsRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountDepositsRequest";
QuerySubaccountDepositsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount", kind: "message", T: Subaccount },
]);
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositsResponse
 */
export class QuerySubaccountDepositsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: map<string, injective.exchange.v1beta1.Deposit> deposits = 1;
         */
        this.deposits = {};
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountDepositsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountDepositsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountDepositsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountDepositsResponse, a, b);
    }
}
QuerySubaccountDepositsResponse.runtime = proto3;
QuerySubaccountDepositsResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountDepositsResponse";
QuerySubaccountDepositsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "deposits", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: Deposit } },
]);
/**
 * QueryExchangeBalancesRequest is the request type for the
 * Query/ExchangeBalances RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeBalancesRequest
 */
export class QueryExchangeBalancesRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExchangeBalancesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExchangeBalancesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExchangeBalancesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExchangeBalancesRequest, a, b);
    }
}
QueryExchangeBalancesRequest.runtime = proto3;
QueryExchangeBalancesRequest.typeName = "injective.exchange.v1beta1.QueryExchangeBalancesRequest";
QueryExchangeBalancesRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeBalancesResponse
 */
export class QueryExchangeBalancesResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.Balance balances = 1;
         */
        this.balances = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExchangeBalancesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExchangeBalancesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExchangeBalancesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExchangeBalancesResponse, a, b);
    }
}
QueryExchangeBalancesResponse.runtime = proto3;
QueryExchangeBalancesResponse.typeName = "injective.exchange.v1beta1.QueryExchangeBalancesResponse";
QueryExchangeBalancesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
]);
/**
 * QueryAggregateVolumeRequest is the request type for the Query/AggregateVolume
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumeRequest
 */
export class QueryAggregateVolumeRequest extends Message {
    constructor(data) {
        super();
        /**
         * can either be an address or a subaccount
         *
         * @generated from field: string account = 1;
         */
        this.account = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateVolumeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateVolumeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateVolumeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateVolumeRequest, a, b);
    }
}
QueryAggregateVolumeRequest.runtime = proto3;
QueryAggregateVolumeRequest.typeName = "injective.exchange.v1beta1.QueryAggregateVolumeRequest";
QueryAggregateVolumeRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryAggregateVolumeResponse is the response type for the
 * Query/AggregateVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumeResponse
 */
export class QueryAggregateVolumeResponse extends Message {
    constructor(data) {
        super();
        /**
         * if an address is specified, then the aggregate_volumes will aggregate the
         * volumes across all subaccounts for the address
         *
         * @generated from field: repeated injective.exchange.v1beta1.MarketVolume aggregate_volumes = 1;
         */
        this.aggregateVolumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateVolumeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateVolumeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateVolumeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateVolumeResponse, a, b);
    }
}
QueryAggregateVolumeResponse.runtime = proto3;
QueryAggregateVolumeResponse.typeName = "injective.exchange.v1beta1.QueryAggregateVolumeResponse";
QueryAggregateVolumeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_volumes", kind: "message", T: MarketVolume, repeated: true },
]);
/**
 * QueryAggregateVolumesRequest is the request type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumesRequest
 */
export class QueryAggregateVolumesRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string accounts = 1;
         */
        this.accounts = [];
        /**
         * @generated from field: repeated string market_ids = 2;
         */
        this.marketIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateVolumesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateVolumesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateVolumesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateVolumesRequest, a, b);
    }
}
QueryAggregateVolumesRequest.runtime = proto3;
QueryAggregateVolumesRequest.typeName = "injective.exchange.v1beta1.QueryAggregateVolumesRequest";
QueryAggregateVolumesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryAggregateVolumesResponse is the response type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumesResponse
 */
export class QueryAggregateVolumesResponse extends Message {
    constructor(data) {
        super();
        /**
         * the aggregate volume records for the accounts specified
         *
         * @generated from field: repeated injective.exchange.v1beta1.AggregateAccountVolumeRecord aggregate_account_volumes = 1;
         */
        this.aggregateAccountVolumes = [];
        /**
         * the aggregate volumes for the markets specified
         *
         * @generated from field: repeated injective.exchange.v1beta1.MarketVolume aggregate_market_volumes = 2;
         */
        this.aggregateMarketVolumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateVolumesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateVolumesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateVolumesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateVolumesResponse, a, b);
    }
}
QueryAggregateVolumesResponse.runtime = proto3;
QueryAggregateVolumesResponse.typeName = "injective.exchange.v1beta1.QueryAggregateVolumesResponse";
QueryAggregateVolumesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_account_volumes", kind: "message", T: AggregateAccountVolumeRecord, repeated: true },
    { no: 2, name: "aggregate_market_volumes", kind: "message", T: MarketVolume, repeated: true },
]);
/**
 * QueryAggregateMarketVolumeRequest is the request type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest
 */
export class QueryAggregateMarketVolumeRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateMarketVolumeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateMarketVolumeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateMarketVolumeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateMarketVolumeRequest, a, b);
    }
}
QueryAggregateMarketVolumeRequest.runtime = proto3;
QueryAggregateMarketVolumeRequest.typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest";
QueryAggregateMarketVolumeRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryAggregateMarketVolumeResponse is the response type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse
 */
export class QueryAggregateMarketVolumeResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateMarketVolumeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateMarketVolumeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateMarketVolumeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateMarketVolumeResponse, a, b);
    }
}
QueryAggregateMarketVolumeResponse.runtime = proto3;
QueryAggregateMarketVolumeResponse.typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse";
QueryAggregateMarketVolumeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "volume", kind: "message", T: VolumeRecord },
]);
/**
 * QueryDenomDecimalRequest is the request type for the Query/DenomDecimal RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalRequest
 */
export class QueryDenomDecimalRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string denom = 1;
         */
        this.denom = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDenomDecimalRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDenomDecimalRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDenomDecimalRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDenomDecimalRequest, a, b);
    }
}
QueryDenomDecimalRequest.runtime = proto3;
QueryDenomDecimalRequest.typeName = "injective.exchange.v1beta1.QueryDenomDecimalRequest";
QueryDenomDecimalRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDenomDecimalResponse is the response type for the Query/DenomDecimal RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalResponse
 */
export class QueryDenomDecimalResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 decimal = 1;
         */
        this.decimal = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDenomDecimalResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDenomDecimalResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDenomDecimalResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDenomDecimalResponse, a, b);
    }
}
QueryDenomDecimalResponse.runtime = proto3;
QueryDenomDecimalResponse.typeName = "injective.exchange.v1beta1.QueryDenomDecimalResponse";
QueryDenomDecimalResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "decimal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * QueryDenomDecimalsRequest is the request type for the Query/DenomDecimals RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalsRequest
 */
export class QueryDenomDecimalsRequest extends Message {
    constructor(data) {
        super();
        /**
         * denoms can be empty to query all denom decimals
         *
         * @generated from field: repeated string denoms = 1;
         */
        this.denoms = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDenomDecimalsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDenomDecimalsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDenomDecimalsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDenomDecimalsRequest, a, b);
    }
}
QueryDenomDecimalsRequest.runtime = proto3;
QueryDenomDecimalsRequest.typeName = "injective.exchange.v1beta1.QueryDenomDecimalsRequest";
QueryDenomDecimalsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalsResponse
 */
export class QueryDenomDecimalsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 1;
         */
        this.denomDecimals = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDenomDecimalsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDenomDecimalsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDenomDecimalsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDenomDecimalsResponse, a, b);
    }
}
QueryDenomDecimalsResponse.runtime = proto3;
QueryDenomDecimalsResponse.typeName = "injective.exchange.v1beta1.QueryDenomDecimalsResponse";
QueryDenomDecimalsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "denom_decimals", kind: "message", T: DenomDecimals, repeated: true },
]);
/**
 * QueryAggregateMarketVolumesRequest is the request type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest
 */
export class QueryAggregateMarketVolumesRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string market_ids = 1;
         */
        this.marketIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateMarketVolumesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateMarketVolumesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateMarketVolumesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateMarketVolumesRequest, a, b);
    }
}
QueryAggregateMarketVolumesRequest.runtime = proto3;
QueryAggregateMarketVolumesRequest.typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest";
QueryAggregateMarketVolumesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryAggregateMarketVolumesResponse is the response type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse
 */
export class QueryAggregateMarketVolumesResponse extends Message {
    constructor(data) {
        super();
        /**
         * the aggregate volumes for the entire market
         *
         * @generated from field: repeated injective.exchange.v1beta1.MarketVolume volumes = 1;
         */
        this.volumes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAggregateMarketVolumesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAggregateMarketVolumesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAggregateMarketVolumesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAggregateMarketVolumesResponse, a, b);
    }
}
QueryAggregateMarketVolumesResponse.runtime = proto3;
QueryAggregateMarketVolumesResponse.typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse";
QueryAggregateMarketVolumesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "volumes", kind: "message", T: MarketVolume, repeated: true },
]);
/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositRequest
 */
export class QuerySubaccountDepositRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string denom = 2;
         */
        this.denom = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountDepositRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountDepositRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountDepositRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountDepositRequest, a, b);
    }
}
QuerySubaccountDepositRequest.runtime = proto3;
QuerySubaccountDepositRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountDepositRequest";
QuerySubaccountDepositRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositResponse
 */
export class QuerySubaccountDepositResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountDepositResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountDepositResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountDepositResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountDepositResponse, a, b);
    }
}
QuerySubaccountDepositResponse.runtime = proto3;
QuerySubaccountDepositResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountDepositResponse";
QuerySubaccountDepositResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "deposits", kind: "message", T: Deposit },
]);
/**
 * QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketsRequest
 */
export class QuerySpotMarketsRequest extends Message {
    constructor(data) {
        super();
        /**
         * Status of the market, for convenience it is set to string - not enum
         *
         * @generated from field: string status = 1;
         */
        this.status = "";
        /**
         * Filter by market IDs
         *
         * @generated from field: repeated string market_ids = 2;
         */
        this.marketIds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMarketsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMarketsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMarketsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMarketsRequest, a, b);
    }
}
QuerySpotMarketsRequest.runtime = proto3;
QuerySpotMarketsRequest.typeName = "injective.exchange.v1beta1.QuerySpotMarketsRequest";
QuerySpotMarketsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketsResponse
 */
export class QuerySpotMarketsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.SpotMarket markets = 1;
         */
        this.markets = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMarketsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMarketsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMarketsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMarketsResponse, a, b);
    }
}
QuerySpotMarketsResponse.runtime = proto3;
QuerySpotMarketsResponse.typeName = "injective.exchange.v1beta1.QuerySpotMarketsResponse";
QuerySpotMarketsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: SpotMarket, repeated: true },
]);
/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketRequest
 */
export class QuerySpotMarketRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMarketRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMarketRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMarketRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMarketRequest, a, b);
    }
}
QuerySpotMarketRequest.runtime = proto3;
QuerySpotMarketRequest.typeName = "injective.exchange.v1beta1.QuerySpotMarketRequest";
QuerySpotMarketRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketResponse
 */
export class QuerySpotMarketResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMarketResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMarketResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMarketResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMarketResponse, a, b);
    }
}
QuerySpotMarketResponse.runtime = proto3;
QuerySpotMarketResponse.typeName = "injective.exchange.v1beta1.QuerySpotMarketResponse";
QuerySpotMarketResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
]);
/**
 * QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrderbookRequest
 */
export class QuerySpotOrderbookRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * @generated from field: uint64 limit = 2;
         */
        this.limit = protoInt64.zero;
        /**
         * @generated from field: injective.exchange.v1beta1.OrderSide order_side = 3;
         */
        this.orderSide = OrderSide.Side_Unspecified;
        /**
         * @generated from field: string limit_cumulative_notional = 4;
         */
        this.limitCumulativeNotional = "";
        /**
         * @generated from field: string limit_cumulative_quantity = 5;
         */
        this.limitCumulativeQuantity = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotOrderbookRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotOrderbookRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotOrderbookRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotOrderbookRequest, a, b);
    }
}
QuerySpotOrderbookRequest.runtime = proto3;
QuerySpotOrderbookRequest.typeName = "injective.exchange.v1beta1.QuerySpotOrderbookRequest";
QuerySpotOrderbookRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "order_side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 4, name: "limit_cumulative_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "limit_cumulative_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrderbookResponse
 */
export class QuerySpotOrderbookResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.Level buys_price_level = 1;
         */
        this.buysPriceLevel = [];
        /**
         * @generated from field: repeated injective.exchange.v1beta1.Level sells_price_level = 2;
         */
        this.sellsPriceLevel = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotOrderbookResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotOrderbookResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotOrderbookResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotOrderbookResponse, a, b);
    }
}
QuerySpotOrderbookResponse.runtime = proto3;
QuerySpotOrderbookResponse.typeName = "injective.exchange.v1beta1.QuerySpotOrderbookResponse";
QuerySpotOrderbookResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "buys_price_level", kind: "message", T: Level, repeated: true },
    { no: 2, name: "sells_price_level", kind: "message", T: Level, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.FullSpotMarket
 */
export class FullSpotMarket extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new FullSpotMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new FullSpotMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new FullSpotMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(FullSpotMarket, a, b);
    }
}
FullSpotMarket.runtime = proto3;
FullSpotMarket.typeName = "injective.exchange.v1beta1.FullSpotMarket";
FullSpotMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
    { no: 2, name: "mid_price_and_tob", kind: "message", T: MidPriceAndTOB },
]);
/**
 * QueryFullSpotMarketsRequest is the request type for the Query/FullSpotMarkets
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketsRequest
 */
export class QueryFullSpotMarketsRequest extends Message {
    constructor(data) {
        super();
        /**
         * Status of the market, for convenience it is set to string - not enum
         *
         * @generated from field: string status = 1;
         */
        this.status = "";
        /**
         * Filter by market IDs
         *
         * @generated from field: repeated string market_ids = 2;
         */
        this.marketIds = [];
        /**
         * Flag to return the markets mid price and top of the book buy and sell
         * orders.
         *
         * @generated from field: bool with_mid_price_and_tob = 3;
         */
        this.withMidPriceAndTob = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFullSpotMarketsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFullSpotMarketsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFullSpotMarketsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFullSpotMarketsRequest, a, b);
    }
}
QueryFullSpotMarketsRequest.runtime = proto3;
QueryFullSpotMarketsRequest.typeName = "injective.exchange.v1beta1.QueryFullSpotMarketsRequest";
QueryFullSpotMarketsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * QueryFullSpotMarketsResponse is the response type for the
 * Query/FullSpotMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketsResponse
 */
export class QueryFullSpotMarketsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.FullSpotMarket markets = 1;
         */
        this.markets = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFullSpotMarketsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFullSpotMarketsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFullSpotMarketsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFullSpotMarketsResponse, a, b);
    }
}
QueryFullSpotMarketsResponse.runtime = proto3;
QueryFullSpotMarketsResponse.typeName = "injective.exchange.v1beta1.QueryFullSpotMarketsResponse";
QueryFullSpotMarketsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: FullSpotMarket, repeated: true },
]);
/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketRequest
 */
export class QueryFullSpotMarketRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * Flag to return the markets mid price and top of the book buy and sell
         * orders.
         *
         * @generated from field: bool with_mid_price_and_tob = 2;
         */
        this.withMidPriceAndTob = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFullSpotMarketRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFullSpotMarketRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFullSpotMarketRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFullSpotMarketRequest, a, b);
    }
}
QueryFullSpotMarketRequest.runtime = proto3;
QueryFullSpotMarketRequest.typeName = "injective.exchange.v1beta1.QueryFullSpotMarketRequest";
QueryFullSpotMarketRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketResponse
 */
export class QueryFullSpotMarketResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFullSpotMarketResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFullSpotMarketResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFullSpotMarketResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFullSpotMarketResponse, a, b);
    }
}
QueryFullSpotMarketResponse.runtime = proto3;
QueryFullSpotMarketResponse.typeName = "injective.exchange.v1beta1.QueryFullSpotMarketResponse";
QueryFullSpotMarketResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: FullSpotMarket },
]);
/**
 * QuerySpotOrdersByHashesRequest is the request type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest
 */
export class QuerySpotOrdersByHashesRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        /**
         * the order hashes
         *
         * @generated from field: repeated string order_hashes = 3;
         */
        this.orderHashes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotOrdersByHashesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotOrdersByHashesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotOrdersByHashesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotOrdersByHashesRequest, a, b);
    }
}
QuerySpotOrdersByHashesRequest.runtime = proto3;
QuerySpotOrdersByHashesRequest.typeName = "injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest";
QuerySpotOrdersByHashesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hashes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QuerySpotOrdersByHashesResponse is the response type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse
 */
export class QuerySpotOrdersByHashesResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotOrdersByHashesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotOrdersByHashesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotOrdersByHashesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotOrdersByHashesResponse, a, b);
    }
}
QuerySpotOrdersByHashesResponse.runtime = proto3;
QuerySpotOrdersByHashesResponse.typeName = "injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse";
QuerySpotOrdersByHashesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
]);
/**
 * QueryTraderSpotOrdersRequest is the request type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersRequest
 */
export class QueryTraderSpotOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderSpotOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderSpotOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderSpotOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderSpotOrdersRequest, a, b);
    }
}
QueryTraderSpotOrdersRequest.runtime = proto3;
QueryTraderSpotOrdersRequest.typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersRequest";
QueryTraderSpotOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest
 */
export class QueryAccountAddressSpotOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * Account address of the trader
         *
         * @generated from field: string account_address = 2;
         */
        this.accountAddress = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAccountAddressSpotOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAccountAddressSpotOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAccountAddressSpotOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAccountAddressSpotOrdersRequest, a, b);
    }
}
QueryAccountAddressSpotOrdersRequest.runtime = proto3;
QueryAccountAddressSpotOrdersRequest.typeName = "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest";
QueryAccountAddressSpotOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.TrimmedSpotLimitOrder
 */
export class TrimmedSpotLimitOrder extends Message {
    constructor(data) {
        super();
        /**
         * price of the order
         *
         * @generated from field: string price = 1;
         */
        this.price = "";
        /**
         * quantity of the order
         *
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * the amount of the quantity remaining fillable
         *
         * @generated from field: string fillable = 3;
         */
        this.fillable = "";
        /**
         * true if the order is a buy
         *
         * @generated from field: bool isBuy = 4;
         */
        this.isBuy = false;
        /**
         * @generated from field: string order_hash = 5;
         */
        this.orderHash = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TrimmedSpotLimitOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TrimmedSpotLimitOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TrimmedSpotLimitOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TrimmedSpotLimitOrder, a, b);
    }
}
TrimmedSpotLimitOrder.runtime = proto3;
TrimmedSpotLimitOrder.typeName = "injective.exchange.v1beta1.TrimmedSpotLimitOrder";
TrimmedSpotLimitOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryTraderSpotOrdersResponse is the response type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersResponse
 */
export class QueryTraderSpotOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderSpotOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderSpotOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderSpotOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderSpotOrdersResponse, a, b);
    }
}
QueryTraderSpotOrdersResponse.runtime = proto3;
QueryTraderSpotOrdersResponse.typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersResponse";
QueryTraderSpotOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
]);
/**
 * QueryAccountAddressSpotOrdersResponse is the response type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse
 */
export class QueryAccountAddressSpotOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAccountAddressSpotOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAccountAddressSpotOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAccountAddressSpotOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAccountAddressSpotOrdersResponse, a, b);
    }
}
QueryAccountAddressSpotOrdersResponse.runtime = proto3;
QueryAccountAddressSpotOrdersResponse.typeName = "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse";
QueryAccountAddressSpotOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
]);
/**
 * QuerySpotMidPriceAndTOBRequest is the request type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest
 */
export class QuerySpotMidPriceAndTOBRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMidPriceAndTOBRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMidPriceAndTOBRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMidPriceAndTOBRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMidPriceAndTOBRequest, a, b);
    }
}
QuerySpotMidPriceAndTOBRequest.runtime = proto3;
QuerySpotMidPriceAndTOBRequest.typeName = "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest";
QuerySpotMidPriceAndTOBRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySpotMidPriceAndTOBResponse is the response type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse
 */
export class QuerySpotMidPriceAndTOBResponse extends Message {
    constructor(data) {
        super();
        /**
         * mid price of the market
         *
         * @generated from field: string mid_price = 1;
         */
        this.midPrice = "";
        /**
         * best buy price of the market
         *
         * @generated from field: string best_buy_price = 2;
         */
        this.bestBuyPrice = "";
        /**
         * best sell price of the market
         *
         * @generated from field: string best_sell_price = 3;
         */
        this.bestSellPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySpotMidPriceAndTOBResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySpotMidPriceAndTOBResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySpotMidPriceAndTOBResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySpotMidPriceAndTOBResponse, a, b);
    }
}
QuerySpotMidPriceAndTOBResponse.runtime = proto3;
QuerySpotMidPriceAndTOBResponse.typeName = "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse";
QuerySpotMidPriceAndTOBResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeMidPriceAndTOBRequest is the request type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest
 */
export class QueryDerivativeMidPriceAndTOBRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMidPriceAndTOBRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMidPriceAndTOBRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMidPriceAndTOBRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMidPriceAndTOBRequest, a, b);
    }
}
QueryDerivativeMidPriceAndTOBRequest.runtime = proto3;
QueryDerivativeMidPriceAndTOBRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest";
QueryDerivativeMidPriceAndTOBRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeMidPriceAndTOBResponse is the response type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse
 */
export class QueryDerivativeMidPriceAndTOBResponse extends Message {
    constructor(data) {
        super();
        /**
         * mid price of the market
         *
         * @generated from field: string mid_price = 1;
         */
        this.midPrice = "";
        /**
         * best buy price of the market
         *
         * @generated from field: string best_buy_price = 2;
         */
        this.bestBuyPrice = "";
        /**
         * best sell price of the market
         *
         * @generated from field: string best_sell_price = 3;
         */
        this.bestSellPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMidPriceAndTOBResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMidPriceAndTOBResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMidPriceAndTOBResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMidPriceAndTOBResponse, a, b);
    }
}
QueryDerivativeMidPriceAndTOBResponse.runtime = proto3;
QueryDerivativeMidPriceAndTOBResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse";
QueryDerivativeMidPriceAndTOBResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeOrderbookRequest is the request type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrderbookRequest
 */
export class QueryDerivativeOrderbookRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * @generated from field: uint64 limit = 2;
         */
        this.limit = protoInt64.zero;
        /**
         * @generated from field: string limit_cumulative_notional = 3;
         */
        this.limitCumulativeNotional = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeOrderbookRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeOrderbookRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeOrderbookRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeOrderbookRequest, a, b);
    }
}
QueryDerivativeOrderbookRequest.runtime = proto3;
QueryDerivativeOrderbookRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeOrderbookRequest";
QueryDerivativeOrderbookRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "limit_cumulative_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeOrderbookResponse is the response type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrderbookResponse
 */
export class QueryDerivativeOrderbookResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.Level buys_price_level = 1;
         */
        this.buysPriceLevel = [];
        /**
         * @generated from field: repeated injective.exchange.v1beta1.Level sells_price_level = 2;
         */
        this.sellsPriceLevel = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeOrderbookResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeOrderbookResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeOrderbookResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeOrderbookResponse, a, b);
    }
}
QueryDerivativeOrderbookResponse.runtime = proto3;
QueryDerivativeOrderbookResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeOrderbookResponse";
QueryDerivativeOrderbookResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "buys_price_level", kind: "message", T: Level, repeated: true },
    { no: 2, name: "sells_price_level", kind: "message", T: Level, repeated: true },
]);
/**
 * QueryTraderSpotOrdersToCancelUpToAmountRequest is the request type for the
 * Query/TraderSpotOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest
 */
export class QueryTraderSpotOrdersToCancelUpToAmountRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        /**
         * the base amount to cancel (free up)
         *
         * @generated from field: string base_amount = 3;
         */
        this.baseAmount = "";
        /**
         * the quote amount to cancel (free up)
         *
         * @generated from field: string quote_amount = 4;
         */
        this.quoteAmount = "";
        /**
         * The cancellation strategy
         *
         * @generated from field: injective.exchange.v1beta1.CancellationStrategy strategy = 5;
         */
        this.strategy = CancellationStrategy.UnspecifiedOrder;
        /**
         * The reference price for the cancellation strategy, e.g. mid price or mark
         * price
         *
         * @generated from field: string reference_price = 6;
         */
        this.referencePrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderSpotOrdersToCancelUpToAmountRequest, a, b);
    }
}
QueryTraderSpotOrdersToCancelUpToAmountRequest.runtime = proto3;
QueryTraderSpotOrdersToCancelUpToAmountRequest.typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest";
QueryTraderSpotOrdersToCancelUpToAmountRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "base_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quote_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "strategy", kind: "enum", T: proto3.getEnumType(CancellationStrategy) },
    { no: 6, name: "reference_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryTraderDerivativeOrdersToCancelUpToAmountRequest is the request type for
 * the Query/TraderDerivativeOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest
 */
export class QueryTraderDerivativeOrdersToCancelUpToAmountRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        /**
         * the quote amount to cancel (free up)
         *
         * @generated from field: string quote_amount = 3;
         */
        this.quoteAmount = "";
        /**
         * The cancellation strategy
         *
         * @generated from field: injective.exchange.v1beta1.CancellationStrategy strategy = 4;
         */
        this.strategy = CancellationStrategy.UnspecifiedOrder;
        /**
         * The reference price for the cancellation strategy, e.g. mid price or mark
         * price
         *
         * @generated from field: string reference_price = 5;
         */
        this.referencePrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderDerivativeOrdersToCancelUpToAmountRequest, a, b);
    }
}
QueryTraderDerivativeOrdersToCancelUpToAmountRequest.runtime = proto3;
QueryTraderDerivativeOrdersToCancelUpToAmountRequest.typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest";
QueryTraderDerivativeOrdersToCancelUpToAmountRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "strategy", kind: "enum", T: proto3.getEnumType(CancellationStrategy) },
    { no: 5, name: "reference_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest
 */
export class QueryTraderDerivativeOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderDerivativeOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderDerivativeOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderDerivativeOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderDerivativeOrdersRequest, a, b);
    }
}
QueryTraderDerivativeOrdersRequest.runtime = proto3;
QueryTraderDerivativeOrdersRequest.typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest";
QueryTraderDerivativeOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest
 */
export class QueryAccountAddressDerivativeOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * Account address of the trader
         *
         * @generated from field: string account_address = 2;
         */
        this.accountAddress = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAccountAddressDerivativeOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAccountAddressDerivativeOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAccountAddressDerivativeOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAccountAddressDerivativeOrdersRequest, a, b);
    }
}
QueryAccountAddressDerivativeOrdersRequest.runtime = proto3;
QueryAccountAddressDerivativeOrdersRequest.typeName = "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest";
QueryAccountAddressDerivativeOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.TrimmedDerivativeLimitOrder
 */
export class TrimmedDerivativeLimitOrder extends Message {
    constructor(data) {
        super();
        /**
         * price of the order
         *
         * @generated from field: string price = 1;
         */
        this.price = "";
        /**
         * quantity of the order
         *
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * margin of the order
         *
         * @generated from field: string margin = 3;
         */
        this.margin = "";
        /**
         * the amount of the quantity remaining fillable
         *
         * @generated from field: string fillable = 4;
         */
        this.fillable = "";
        /**
         * true if the order is a buy
         *
         * ensure omitempty is not in jsontag
         *
         * @generated from field: bool isBuy = 5;
         */
        this.isBuy = false;
        /**
         * @generated from field: string order_hash = 6;
         */
        this.orderHash = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TrimmedDerivativeLimitOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TrimmedDerivativeLimitOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TrimmedDerivativeLimitOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TrimmedDerivativeLimitOrder, a, b);
    }
}
TrimmedDerivativeLimitOrder.runtime = proto3;
TrimmedDerivativeLimitOrder.typeName = "injective.exchange.v1beta1.TrimmedDerivativeLimitOrder";
TrimmedDerivativeLimitOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse
 */
export class QueryTraderDerivativeOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderDerivativeOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderDerivativeOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderDerivativeOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderDerivativeOrdersResponse, a, b);
    }
}
QueryTraderDerivativeOrdersResponse.runtime = proto3;
QueryTraderDerivativeOrdersResponse.typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse";
QueryTraderDerivativeOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
]);
/**
 * QueryAccountAddressDerivativeOrdersResponse is the response type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse
 */
export class QueryAccountAddressDerivativeOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryAccountAddressDerivativeOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryAccountAddressDerivativeOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryAccountAddressDerivativeOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryAccountAddressDerivativeOrdersResponse, a, b);
    }
}
QueryAccountAddressDerivativeOrdersResponse.runtime = proto3;
QueryAccountAddressDerivativeOrdersResponse.typeName = "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse";
QueryAccountAddressDerivativeOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
]);
/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest
 */
export class QueryDerivativeOrdersByHashesRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        /**
         * SubaccountID of the trader
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        /**
         * the order hashes
         *
         * @generated from field: repeated string order_hashes = 3;
         */
        this.orderHashes = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeOrdersByHashesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeOrdersByHashesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeOrdersByHashesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeOrdersByHashesRequest, a, b);
    }
}
QueryDerivativeOrdersByHashesRequest.runtime = proto3;
QueryDerivativeOrdersByHashesRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest";
QueryDerivativeOrdersByHashesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hashes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryDerivativeOrdersByHashesResponse is the response type for the
 * Query/DerivativeOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse
 */
export class QueryDerivativeOrdersByHashesResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeOrdersByHashesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeOrdersByHashesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeOrdersByHashesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeOrdersByHashesResponse, a, b);
    }
}
QueryDerivativeOrdersByHashesResponse.runtime = proto3;
QueryDerivativeOrdersByHashesResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse";
QueryDerivativeOrdersByHashesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
]);
/**
 * QueryDerivativeMarketsRequest is the request type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketsRequest
 */
export class QueryDerivativeMarketsRequest extends Message {
    constructor(data) {
        super();
        /**
         * Status of the market, for convenience it is set to string - not enum
         *
         * @generated from field: string status = 1;
         */
        this.status = "";
        /**
         * Filter by market IDs
         *
         * @generated from field: repeated string market_ids = 2;
         */
        this.marketIds = [];
        /**
         * Flag to return the markets mid price and top of the book buy and sell
         * orders.
         *
         * @generated from field: bool with_mid_price_and_tob = 3;
         */
        this.withMidPriceAndTob = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketsRequest, a, b);
    }
}
QueryDerivativeMarketsRequest.runtime = proto3;
QueryDerivativeMarketsRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketsRequest";
QueryDerivativeMarketsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.PriceLevel
 */
export class PriceLevel extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string price = 1;
         */
        this.price = "";
        /**
         * quantity
         *
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PriceLevel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PriceLevel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PriceLevel().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PriceLevel, a, b);
    }
}
PriceLevel.runtime = proto3;
PriceLevel.typeName = "injective.exchange.v1beta1.PriceLevel";
PriceLevel.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketState
 */
export class PerpetualMarketState extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PerpetualMarketState().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PerpetualMarketState().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PerpetualMarketState().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PerpetualMarketState, a, b);
    }
}
PerpetualMarketState.runtime = proto3;
PerpetualMarketState.typeName = "injective.exchange.v1beta1.PerpetualMarketState";
PerpetualMarketState.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_info", kind: "message", T: PerpetualMarketInfo },
    { no: 2, name: "funding_info", kind: "message", T: PerpetualMarketFunding },
]);
/**
 * @generated from message injective.exchange.v1beta1.FullDerivativeMarket
 */
export class FullDerivativeMarket extends Message {
    constructor(data) {
        super();
        /**
         * @generated from oneof injective.exchange.v1beta1.FullDerivativeMarket.info
         */
        this.info = { case: undefined };
        /**
         * @generated from field: string mark_price = 4;
         */
        this.markPrice = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new FullDerivativeMarket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new FullDerivativeMarket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new FullDerivativeMarket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(FullDerivativeMarket, a, b);
    }
}
FullDerivativeMarket.runtime = proto3;
FullDerivativeMarket.typeName = "injective.exchange.v1beta1.FullDerivativeMarket";
FullDerivativeMarket.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 2, name: "perpetual_info", kind: "message", T: PerpetualMarketState, oneof: "info" },
    { no: 3, name: "futures_info", kind: "message", T: ExpiryFuturesMarketInfo, oneof: "info" },
    { no: 4, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "mid_price_and_tob", kind: "message", T: MidPriceAndTOB },
]);
/**
 * QueryDerivativeMarketsResponse is the response type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketsResponse
 */
export class QueryDerivativeMarketsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.FullDerivativeMarket markets = 1;
         */
        this.markets = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketsResponse, a, b);
    }
}
QueryDerivativeMarketsResponse.runtime = proto3;
QueryDerivativeMarketsResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketsResponse";
QueryDerivativeMarketsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: FullDerivativeMarket, repeated: true },
]);
/**
 * QueryDerivativeMarketRequest is the request type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketRequest
 */
export class QueryDerivativeMarketRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketRequest, a, b);
    }
}
QueryDerivativeMarketRequest.runtime = proto3;
QueryDerivativeMarketRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketRequest";
QueryDerivativeMarketRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeMarketResponse is the response type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketResponse
 */
export class QueryDerivativeMarketResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketResponse, a, b);
    }
}
QueryDerivativeMarketResponse.runtime = proto3;
QueryDerivativeMarketResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketResponse";
QueryDerivativeMarketResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: FullDerivativeMarket },
]);
/**
 * QueryDerivativeMarketAddressRequest is the request type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest
 */
export class QueryDerivativeMarketAddressRequest extends Message {
    constructor(data) {
        super();
        /**
         * Market ID for the market
         *
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketAddressRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketAddressRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketAddressRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketAddressRequest, a, b);
    }
}
QueryDerivativeMarketAddressRequest.runtime = proto3;
QueryDerivativeMarketAddressRequest.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest";
QueryDerivativeMarketAddressRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryDerivativeMarketAddressResponse is the response type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse
 */
export class QueryDerivativeMarketAddressResponse extends Message {
    constructor(data) {
        super();
        /**
         * address for the market
         *
         * @generated from field: string address = 1;
         */
        this.address = "";
        /**
         * subaccountID for the market
         *
         * @generated from field: string subaccount_id = 2;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryDerivativeMarketAddressResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryDerivativeMarketAddressResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryDerivativeMarketAddressResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryDerivativeMarketAddressResponse, a, b);
    }
}
QueryDerivativeMarketAddressResponse.runtime = proto3;
QueryDerivativeMarketAddressResponse.typeName = "injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse";
QueryDerivativeMarketAddressResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountTradeNonceRequest is the request type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest
 */
export class QuerySubaccountTradeNonceRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountTradeNonceRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountTradeNonceRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountTradeNonceRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountTradeNonceRequest, a, b);
    }
}
QuerySubaccountTradeNonceRequest.runtime = proto3;
QuerySubaccountTradeNonceRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest";
QuerySubaccountTradeNonceRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountPositionsRequest is the request type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionsRequest
 */
export class QuerySubaccountPositionsRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountPositionsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountPositionsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountPositionsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountPositionsRequest, a, b);
    }
}
QuerySubaccountPositionsRequest.runtime = proto3;
QuerySubaccountPositionsRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountPositionsRequest";
QuerySubaccountPositionsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountPositionInMarketRequest is the request type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest
 */
export class QuerySubaccountPositionInMarketRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string market_id = 2;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountPositionInMarketRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountPositionInMarketRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountPositionInMarketRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountPositionInMarketRequest, a, b);
    }
}
QuerySubaccountPositionInMarketRequest.runtime = proto3;
QuerySubaccountPositionInMarketRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest";
QuerySubaccountPositionInMarketRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountEffectivePositionInMarketRequest is the request type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest
 */
export class QuerySubaccountEffectivePositionInMarketRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string market_id = 2;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountEffectivePositionInMarketRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountEffectivePositionInMarketRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountEffectivePositionInMarketRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountEffectivePositionInMarketRequest, a, b);
    }
}
QuerySubaccountEffectivePositionInMarketRequest.runtime = proto3;
QuerySubaccountEffectivePositionInMarketRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest";
QuerySubaccountEffectivePositionInMarketRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountOrderMetadataRequest is the request type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest
 */
export class QuerySubaccountOrderMetadataRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountOrderMetadataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountOrderMetadataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountOrderMetadataRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountOrderMetadataRequest, a, b);
    }
}
QuerySubaccountOrderMetadataRequest.runtime = proto3;
QuerySubaccountOrderMetadataRequest.typeName = "injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest";
QuerySubaccountOrderMetadataRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountPositionsResponse is the response type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionsResponse
 */
export class QuerySubaccountPositionsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.DerivativePosition state = 1;
         */
        this.state = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountPositionsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountPositionsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountPositionsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountPositionsResponse, a, b);
    }
}
QuerySubaccountPositionsResponse.runtime = proto3;
QuerySubaccountPositionsResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountPositionsResponse";
QuerySubaccountPositionsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: DerivativePosition, repeated: true },
]);
/**
 * QuerySubaccountPositionInMarketResponse is the response type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse
 */
export class QuerySubaccountPositionInMarketResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountPositionInMarketResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountPositionInMarketResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountPositionInMarketResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountPositionInMarketResponse, a, b);
    }
}
QuerySubaccountPositionInMarketResponse.runtime = proto3;
QuerySubaccountPositionInMarketResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse";
QuerySubaccountPositionInMarketResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: Position },
]);
/**
 * @generated from message injective.exchange.v1beta1.EffectivePosition
 */
export class EffectivePosition extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bool is_long = 1;
         */
        this.isLong = false;
        /**
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * @generated from field: string entry_price = 3;
         */
        this.entryPrice = "";
        /**
         * @generated from field: string effective_margin = 4;
         */
        this.effectiveMargin = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new EffectivePosition().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new EffectivePosition().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new EffectivePosition().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(EffectivePosition, a, b);
    }
}
EffectivePosition.runtime = proto3;
EffectivePosition.typeName = "injective.exchange.v1beta1.EffectivePosition";
EffectivePosition.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "is_long", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "effective_margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QuerySubaccountEffectivePositionInMarketResponse is the response type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse
 */
export class QuerySubaccountEffectivePositionInMarketResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountEffectivePositionInMarketResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountEffectivePositionInMarketResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountEffectivePositionInMarketResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountEffectivePositionInMarketResponse, a, b);
    }
}
QuerySubaccountEffectivePositionInMarketResponse.runtime = proto3;
QuerySubaccountEffectivePositionInMarketResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse";
QuerySubaccountEffectivePositionInMarketResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: EffectivePosition },
]);
/**
 * QueryPerpetualMarketInfoRequest is the request type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest
 */
export class QueryPerpetualMarketInfoRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPerpetualMarketInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPerpetualMarketInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPerpetualMarketInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPerpetualMarketInfoRequest, a, b);
    }
}
QueryPerpetualMarketInfoRequest.runtime = proto3;
QueryPerpetualMarketInfoRequest.typeName = "injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest";
QueryPerpetualMarketInfoRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryPerpetualMarketInfoResponse is the response type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse
 */
export class QueryPerpetualMarketInfoResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPerpetualMarketInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPerpetualMarketInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPerpetualMarketInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPerpetualMarketInfoResponse, a, b);
    }
}
QueryPerpetualMarketInfoResponse.runtime = proto3;
QueryPerpetualMarketInfoResponse.typeName = "injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse";
QueryPerpetualMarketInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: PerpetualMarketInfo },
]);
/**
 * QueryExpiryFuturesMarketInfoRequest is the request type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest
 */
export class QueryExpiryFuturesMarketInfoRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExpiryFuturesMarketInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExpiryFuturesMarketInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExpiryFuturesMarketInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExpiryFuturesMarketInfoRequest, a, b);
    }
}
QueryExpiryFuturesMarketInfoRequest.runtime = proto3;
QueryExpiryFuturesMarketInfoRequest.typeName = "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest";
QueryExpiryFuturesMarketInfoRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryExpiryFuturesMarketInfoResponse is the response type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse
 */
export class QueryExpiryFuturesMarketInfoResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryExpiryFuturesMarketInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryExpiryFuturesMarketInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryExpiryFuturesMarketInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryExpiryFuturesMarketInfoResponse, a, b);
    }
}
QueryExpiryFuturesMarketInfoResponse.runtime = proto3;
QueryExpiryFuturesMarketInfoResponse.typeName = "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse";
QueryExpiryFuturesMarketInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: ExpiryFuturesMarketInfo },
]);
/**
 * QueryPerpetualMarketFundingRequest is the request type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest
 */
export class QueryPerpetualMarketFundingRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPerpetualMarketFundingRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPerpetualMarketFundingRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPerpetualMarketFundingRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPerpetualMarketFundingRequest, a, b);
    }
}
QueryPerpetualMarketFundingRequest.runtime = proto3;
QueryPerpetualMarketFundingRequest.typeName = "injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest";
QueryPerpetualMarketFundingRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryPerpetualMarketFundingResponse is the response type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse
 */
export class QueryPerpetualMarketFundingResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPerpetualMarketFundingResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPerpetualMarketFundingResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPerpetualMarketFundingResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPerpetualMarketFundingResponse, a, b);
    }
}
QueryPerpetualMarketFundingResponse.runtime = proto3;
QueryPerpetualMarketFundingResponse.typeName = "injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse";
QueryPerpetualMarketFundingResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: PerpetualMarketFunding },
]);
/**
 * QuerySubaccountOrderMetadataResponse is the response type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse
 */
export class QuerySubaccountOrderMetadataResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket metadata = 1;
         */
        this.metadata = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountOrderMetadataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountOrderMetadataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountOrderMetadataResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountOrderMetadataResponse, a, b);
    }
}
QuerySubaccountOrderMetadataResponse.runtime = proto3;
QuerySubaccountOrderMetadataResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse";
QuerySubaccountOrderMetadataResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: SubaccountOrderbookMetadataWithMarket, repeated: true },
]);
/**
 * QuerySubaccountTradeNonceResponse is the response type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse
 */
export class QuerySubaccountTradeNonceResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 nonce = 1;
         */
        this.nonce = 0;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QuerySubaccountTradeNonceResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QuerySubaccountTradeNonceResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QuerySubaccountTradeNonceResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QuerySubaccountTradeNonceResponse, a, b);
    }
}
QuerySubaccountTradeNonceResponse.runtime = proto3;
QuerySubaccountTradeNonceResponse.typeName = "injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse";
QuerySubaccountTradeNonceResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * QueryModuleStateRequest is the request type for the Query/ExchangeModuleState
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryModuleStateRequest
 */
export class QueryModuleStateRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryModuleStateRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryModuleStateRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryModuleStateRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryModuleStateRequest, a, b);
    }
}
QueryModuleStateRequest.runtime = proto3;
QueryModuleStateRequest.typeName = "injective.exchange.v1beta1.QueryModuleStateRequest";
QueryModuleStateRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryModuleStateResponse is the response type for the
 * Query/ExchangeModuleState RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryModuleStateResponse
 */
export class QueryModuleStateResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryModuleStateResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryModuleStateResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryModuleStateResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryModuleStateResponse, a, b);
    }
}
QueryModuleStateResponse.runtime = proto3;
QueryModuleStateResponse.typeName = "injective.exchange.v1beta1.QueryModuleStateResponse";
QueryModuleStateResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: GenesisState },
]);
/**
 * QueryPositionsRequest is the request type for the Query/Positions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPositionsRequest
 */
export class QueryPositionsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPositionsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPositionsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPositionsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPositionsRequest, a, b);
    }
}
QueryPositionsRequest.runtime = proto3;
QueryPositionsRequest.typeName = "injective.exchange.v1beta1.QueryPositionsRequest";
QueryPositionsRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryPositionsResponse is the response type for the Query/Positions RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPositionsResponse
 */
export class QueryPositionsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.DerivativePosition state = 1;
         */
        this.state = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryPositionsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryPositionsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryPositionsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryPositionsResponse, a, b);
    }
}
QueryPositionsResponse.runtime = proto3;
QueryPositionsResponse.typeName = "injective.exchange.v1beta1.QueryPositionsResponse";
QueryPositionsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: DerivativePosition, repeated: true },
]);
/**
 * QueryTradeRewardPointsRequest is the request type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardPointsRequest
 */
export class QueryTradeRewardPointsRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string accounts = 1;
         */
        this.accounts = [];
        /**
         * @generated from field: int64 pending_pool_timestamp = 2;
         */
        this.pendingPoolTimestamp = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTradeRewardPointsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTradeRewardPointsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTradeRewardPointsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTradeRewardPointsRequest, a, b);
    }
}
QueryTradeRewardPointsRequest.runtime = proto3;
QueryTradeRewardPointsRequest.typeName = "injective.exchange.v1beta1.QueryTradeRewardPointsRequest";
QueryTradeRewardPointsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "pending_pool_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * QueryTradeRewardPointsResponse is the response type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardPointsResponse
 */
export class QueryTradeRewardPointsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string account_trade_reward_points = 1;
         */
        this.accountTradeRewardPoints = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTradeRewardPointsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTradeRewardPointsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTradeRewardPointsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTradeRewardPointsResponse, a, b);
    }
}
QueryTradeRewardPointsResponse.runtime = proto3;
QueryTradeRewardPointsResponse.typeName = "injective.exchange.v1beta1.QueryTradeRewardPointsResponse";
QueryTradeRewardPointsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryTradeRewardCampaignRequest is the request type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardCampaignRequest
 */
export class QueryTradeRewardCampaignRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTradeRewardCampaignRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTradeRewardCampaignRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTradeRewardCampaignRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTradeRewardCampaignRequest, a, b);
    }
}
QueryTradeRewardCampaignRequest.runtime = proto3;
QueryTradeRewardCampaignRequest.typeName = "injective.exchange.v1beta1.QueryTradeRewardCampaignRequest";
QueryTradeRewardCampaignRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryTradeRewardCampaignResponse is the response type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardCampaignResponse
 */
export class QueryTradeRewardCampaignResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2;
         */
        this.tradingRewardPoolCampaignSchedule = [];
        /**
         * @generated from field: string total_trade_reward_points = 3;
         */
        this.totalTradeRewardPoints = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4;
         */
        this.pendingTradingRewardPoolCampaignSchedule = [];
        /**
         * @generated from field: repeated string pending_total_trade_reward_points = 5;
         */
        this.pendingTotalTradeRewardPoints = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTradeRewardCampaignResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTradeRewardCampaignResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTradeRewardCampaignResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTradeRewardCampaignResponse, a, b);
    }
}
QueryTradeRewardCampaignResponse.runtime = proto3;
QueryTradeRewardCampaignResponse.typeName = "injective.exchange.v1beta1.QueryTradeRewardCampaignResponse";
QueryTradeRewardCampaignResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trading_reward_campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 2, name: "trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 3, name: "total_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 5, name: "pending_total_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryIsRegisteredDMMRequest is the request type for the Query/IsRegisteredDMM
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest
 */
export class QueryIsOptedOutOfRewardsRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string account = 1;
         */
        this.account = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryIsOptedOutOfRewardsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryIsOptedOutOfRewardsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryIsOptedOutOfRewardsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryIsOptedOutOfRewardsRequest, a, b);
    }
}
QueryIsOptedOutOfRewardsRequest.runtime = proto3;
QueryIsOptedOutOfRewardsRequest.typeName = "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest";
QueryIsOptedOutOfRewardsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryIsRegisteredDMMResponse is the response type for the
 * Query/IsRegisteredDMM RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse
 */
export class QueryIsOptedOutOfRewardsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: bool is_opted_out = 1;
         */
        this.isOptedOut = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryIsOptedOutOfRewardsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryIsOptedOutOfRewardsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryIsOptedOutOfRewardsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryIsOptedOutOfRewardsResponse, a, b);
    }
}
QueryIsOptedOutOfRewardsResponse.runtime = proto3;
QueryIsOptedOutOfRewardsResponse.typeName = "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse";
QueryIsOptedOutOfRewardsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "is_opted_out", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * QueryRegisteredDMMsRequest is the request type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest
 */
export class QueryOptedOutOfRewardsAccountsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryOptedOutOfRewardsAccountsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryOptedOutOfRewardsAccountsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryOptedOutOfRewardsAccountsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryOptedOutOfRewardsAccountsRequest, a, b);
    }
}
QueryOptedOutOfRewardsAccountsRequest.runtime = proto3;
QueryOptedOutOfRewardsAccountsRequest.typeName = "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest";
QueryOptedOutOfRewardsAccountsRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryRegisteredDMMsResponse is the response type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse
 */
export class QueryOptedOutOfRewardsAccountsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string accounts = 1;
         */
        this.accounts = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryOptedOutOfRewardsAccountsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryOptedOutOfRewardsAccountsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryOptedOutOfRewardsAccountsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryOptedOutOfRewardsAccountsResponse, a, b);
    }
}
QueryOptedOutOfRewardsAccountsResponse.runtime = proto3;
QueryOptedOutOfRewardsAccountsResponse.typeName = "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse";
QueryOptedOutOfRewardsAccountsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryFeeDiscountAccountInfoRequest is the request type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest
 */
export class QueryFeeDiscountAccountInfoRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string account = 1;
         */
        this.account = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountAccountInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountAccountInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountAccountInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountAccountInfoRequest, a, b);
    }
}
QueryFeeDiscountAccountInfoRequest.runtime = proto3;
QueryFeeDiscountAccountInfoRequest.typeName = "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest";
QueryFeeDiscountAccountInfoRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryFeeDiscountAccountInfoResponse is the response type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse
 */
export class QueryFeeDiscountAccountInfoResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 tier_level = 1;
         */
        this.tierLevel = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountAccountInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountAccountInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountAccountInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountAccountInfoResponse, a, b);
    }
}
QueryFeeDiscountAccountInfoResponse.runtime = proto3;
QueryFeeDiscountAccountInfoResponse.typeName = "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse";
QueryFeeDiscountAccountInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "tier_level", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "account_info", kind: "message", T: FeeDiscountTierInfo },
    { no: 3, name: "account_ttl", kind: "message", T: FeeDiscountTierTTL },
]);
/**
 * QueryFeeDiscountScheduleRequest is the request type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest
 */
export class QueryFeeDiscountScheduleRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountScheduleRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountScheduleRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountScheduleRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountScheduleRequest, a, b);
    }
}
QueryFeeDiscountScheduleRequest.runtime = proto3;
QueryFeeDiscountScheduleRequest.typeName = "injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest";
QueryFeeDiscountScheduleRequest.fields = proto3.util.newFieldList(() => []);
/**
 * QueryFeeDiscountScheduleResponse is the response type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse
 */
export class QueryFeeDiscountScheduleResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountScheduleResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountScheduleResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountScheduleResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountScheduleResponse, a, b);
    }
}
QueryFeeDiscountScheduleResponse.runtime = proto3;
QueryFeeDiscountScheduleResponse.typeName = "injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse";
QueryFeeDiscountScheduleResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "fee_discount_schedule", kind: "message", T: FeeDiscountSchedule },
]);
/**
 * QueryBalanceMismatchesRequest is the request type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceMismatchesRequest
 */
export class QueryBalanceMismatchesRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 dust_factor = 1;
         */
        this.dustFactor = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBalanceMismatchesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBalanceMismatchesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBalanceMismatchesRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBalanceMismatchesRequest, a, b);
    }
}
QueryBalanceMismatchesRequest.runtime = proto3;
QueryBalanceMismatchesRequest.typeName = "injective.exchange.v1beta1.QueryBalanceMismatchesRequest";
QueryBalanceMismatchesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "dust_factor", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.BalanceMismatch
 */
export class BalanceMismatch extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccountId = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string denom = 2;
         */
        this.denom = "";
        /**
         * @generated from field: string available = 3;
         */
        this.available = "";
        /**
         * @generated from field: string total = 4;
         */
        this.total = "";
        /**
         * @generated from field: string balance_hold = 5;
         */
        this.balanceHold = "";
        /**
         * @generated from field: string expected_total = 6;
         */
        this.expectedTotal = "";
        /**
         * @generated from field: string difference = 7;
         */
        this.difference = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BalanceMismatch().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BalanceMismatch().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BalanceMismatch().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BalanceMismatch, a, b);
    }
}
BalanceMismatch.runtime = proto3;
BalanceMismatch.typeName = "injective.exchange.v1beta1.BalanceMismatch";
BalanceMismatch.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccountId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "available", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "expected_total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "difference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryBalanceMismatchesResponse is the response type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceMismatchesResponse
 */
export class QueryBalanceMismatchesResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.BalanceMismatch balance_mismatches = 1;
         */
        this.balanceMismatches = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBalanceMismatchesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBalanceMismatchesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBalanceMismatchesResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBalanceMismatchesResponse, a, b);
    }
}
QueryBalanceMismatchesResponse.runtime = proto3;
QueryBalanceMismatchesResponse.typeName = "injective.exchange.v1beta1.QueryBalanceMismatchesResponse";
QueryBalanceMismatchesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "balance_mismatches", kind: "message", T: BalanceMismatch, repeated: true },
]);
/**
 * QueryBalanceWithBalanceHoldsRequest is the request type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest
 */
export class QueryBalanceWithBalanceHoldsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBalanceWithBalanceHoldsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBalanceWithBalanceHoldsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBalanceWithBalanceHoldsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBalanceWithBalanceHoldsRequest, a, b);
    }
}
QueryBalanceWithBalanceHoldsRequest.runtime = proto3;
QueryBalanceWithBalanceHoldsRequest.typeName = "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest";
QueryBalanceWithBalanceHoldsRequest.fields = proto3.util.newFieldList(() => []);
/**
 * @generated from message injective.exchange.v1beta1.BalanceWithMarginHold
 */
export class BalanceWithMarginHold extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccountId = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string denom = 2;
         */
        this.denom = "";
        /**
         * @generated from field: string available = 3;
         */
        this.available = "";
        /**
         * @generated from field: string total = 4;
         */
        this.total = "";
        /**
         * @generated from field: string balance_hold = 5;
         */
        this.balanceHold = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BalanceWithMarginHold().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BalanceWithMarginHold().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BalanceWithMarginHold().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(BalanceWithMarginHold, a, b);
    }
}
BalanceWithMarginHold.runtime = proto3;
BalanceWithMarginHold.typeName = "injective.exchange.v1beta1.BalanceWithMarginHold";
BalanceWithMarginHold.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccountId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "available", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryBalanceWithBalanceHoldsResponse is the response type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse
 */
export class QueryBalanceWithBalanceHoldsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.BalanceWithMarginHold balance_with_balance_holds = 1;
         */
        this.balanceWithBalanceHolds = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBalanceWithBalanceHoldsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBalanceWithBalanceHoldsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBalanceWithBalanceHoldsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBalanceWithBalanceHoldsResponse, a, b);
    }
}
QueryBalanceWithBalanceHoldsResponse.runtime = proto3;
QueryBalanceWithBalanceHoldsResponse.typeName = "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse";
QueryBalanceWithBalanceHoldsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "balance_with_balance_holds", kind: "message", T: BalanceWithMarginHold, repeated: true },
]);
/**
 * QueryFeeDiscountTierStatisticsRequest is the request type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest
 */
export class QueryFeeDiscountTierStatisticsRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountTierStatisticsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountTierStatisticsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountTierStatisticsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountTierStatisticsRequest, a, b);
    }
}
QueryFeeDiscountTierStatisticsRequest.runtime = proto3;
QueryFeeDiscountTierStatisticsRequest.typeName = "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest";
QueryFeeDiscountTierStatisticsRequest.fields = proto3.util.newFieldList(() => []);
/**
 * @generated from message injective.exchange.v1beta1.TierStatistic
 */
export class TierStatistic extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint64 tier = 1;
         */
        this.tier = protoInt64.zero;
        /**
         * @generated from field: uint64 count = 2;
         */
        this.count = protoInt64.zero;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TierStatistic().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TierStatistic().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TierStatistic().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TierStatistic, a, b);
    }
}
TierStatistic.runtime = proto3;
TierStatistic.typeName = "injective.exchange.v1beta1.TierStatistic";
TierStatistic.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
]);
/**
 * QueryFeeDiscountTierStatisticsResponse is the response type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse
 */
export class QueryFeeDiscountTierStatisticsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TierStatistic statistics = 1;
         */
        this.statistics = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryFeeDiscountTierStatisticsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryFeeDiscountTierStatisticsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryFeeDiscountTierStatisticsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryFeeDiscountTierStatisticsResponse, a, b);
    }
}
QueryFeeDiscountTierStatisticsResponse.runtime = proto3;
QueryFeeDiscountTierStatisticsResponse.typeName = "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse";
QueryFeeDiscountTierStatisticsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "statistics", kind: "message", T: TierStatistic, repeated: true },
]);
/**
 * MitoVaultInfosRequest is the request type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.MitoVaultInfosRequest
 */
export class MitoVaultInfosRequest extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MitoVaultInfosRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MitoVaultInfosRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MitoVaultInfosRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MitoVaultInfosRequest, a, b);
    }
}
MitoVaultInfosRequest.runtime = proto3;
MitoVaultInfosRequest.typeName = "injective.exchange.v1beta1.MitoVaultInfosRequest";
MitoVaultInfosRequest.fields = proto3.util.newFieldList(() => []);
/**
 * MitoVaultInfosResponse is the response type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.MitoVaultInfosResponse
 */
export class MitoVaultInfosResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated string master_addresses = 1;
         */
        this.masterAddresses = [];
        /**
         * @generated from field: repeated string derivative_addresses = 2;
         */
        this.derivativeAddresses = [];
        /**
         * @generated from field: repeated string spot_addresses = 3;
         */
        this.spotAddresses = [];
        /**
         * @generated from field: repeated string cw20_addresses = 4;
         */
        this.cw20Addresses = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new MitoVaultInfosResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MitoVaultInfosResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MitoVaultInfosResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MitoVaultInfosResponse, a, b);
    }
}
MitoVaultInfosResponse.runtime = proto3;
MitoVaultInfosResponse.typeName = "injective.exchange.v1beta1.MitoVaultInfosResponse";
MitoVaultInfosResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "master_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "derivative_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "spot_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "cw20_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * QueryMarketIDFromVaultRequest is the request type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketIDFromVaultRequest
 */
export class QueryMarketIDFromVaultRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string vault_address = 1;
         */
        this.vaultAddress = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketIDFromVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketIDFromVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketIDFromVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketIDFromVaultRequest, a, b);
    }
}
QueryMarketIDFromVaultRequest.runtime = proto3;
QueryMarketIDFromVaultRequest.typeName = "injective.exchange.v1beta1.QueryMarketIDFromVaultRequest";
QueryMarketIDFromVaultRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "vault_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryMarketIDFromVaultResponse is the response type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketIDFromVaultResponse
 */
export class QueryMarketIDFromVaultResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketIDFromVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketIDFromVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketIDFromVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketIDFromVaultResponse, a, b);
    }
}
QueryMarketIDFromVaultResponse.runtime = proto3;
QueryMarketIDFromVaultResponse.typeName = "injective.exchange.v1beta1.QueryMarketIDFromVaultResponse";
QueryMarketIDFromVaultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest
 */
export class QueryHistoricalTradeRecordsRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryHistoricalTradeRecordsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryHistoricalTradeRecordsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryHistoricalTradeRecordsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryHistoricalTradeRecordsRequest, a, b);
    }
}
QueryHistoricalTradeRecordsRequest.runtime = proto3;
QueryHistoricalTradeRecordsRequest.typeName = "injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest";
QueryHistoricalTradeRecordsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse
 */
export class QueryHistoricalTradeRecordsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TradeRecords trade_records = 1;
         */
        this.tradeRecords = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryHistoricalTradeRecordsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryHistoricalTradeRecordsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryHistoricalTradeRecordsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryHistoricalTradeRecordsResponse, a, b);
    }
}
QueryHistoricalTradeRecordsResponse.runtime = proto3;
QueryHistoricalTradeRecordsResponse.typeName = "injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse";
QueryHistoricalTradeRecordsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trade_records", kind: "message", T: TradeRecords, repeated: true },
]);
/**
 * TradeHistoryOptions are the optional params for Query/MarketVolatility RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.TradeHistoryOptions
 */
export class TradeHistoryOptions extends Message {
    constructor(data) {
        super();
        /**
         * TradeGroupingSec of 0 means use the chain's default grouping
         *
         * @generated from field: uint64 trade_grouping_sec = 1;
         */
        this.tradeGroupingSec = protoInt64.zero;
        /**
         * MaxAge restricts the trade records oldest age in seconds from the current
         * block time to consider. A value of 0 means use all the records present on
         * the chain.
         *
         * @generated from field: uint64 max_age = 2;
         */
        this.maxAge = protoInt64.zero;
        /**
         * If IncludeRawHistory is true, the raw underlying data used for the
         * computation is included in the response
         *
         * @generated from field: bool include_raw_history = 4;
         */
        this.includeRawHistory = false;
        /**
         * If IncludeMetadata is true, metadata on the computation is included in the
         * response
         *
         * @generated from field: bool include_metadata = 5;
         */
        this.includeMetadata = false;
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TradeHistoryOptions().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TradeHistoryOptions().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TradeHistoryOptions().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TradeHistoryOptions, a, b);
    }
}
TradeHistoryOptions.runtime = proto3;
TradeHistoryOptions.typeName = "injective.exchange.v1beta1.TradeHistoryOptions";
TradeHistoryOptions.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trade_grouping_sec", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max_age", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "include_raw_history", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "include_metadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * QueryMarketVolatilityRequest are the request params for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketVolatilityRequest
 */
export class QueryMarketVolatilityRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketVolatilityRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketVolatilityRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketVolatilityRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketVolatilityRequest, a, b);
    }
}
QueryMarketVolatilityRequest.runtime = proto3;
QueryMarketVolatilityRequest.typeName = "injective.exchange.v1beta1.QueryMarketVolatilityRequest";
QueryMarketVolatilityRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trade_history_options", kind: "message", T: TradeHistoryOptions },
]);
/**
 * QueryMarketVolatilityResponse is the response type for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketVolatilityResponse
 */
export class QueryMarketVolatilityResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string volatility = 1;
         */
        this.volatility = "";
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TradeRecord raw_history = 3;
         */
        this.rawHistory = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketVolatilityResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketVolatilityResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketVolatilityResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketVolatilityResponse, a, b);
    }
}
QueryMarketVolatilityResponse.runtime = proto3;
QueryMarketVolatilityResponse.typeName = "injective.exchange.v1beta1.QueryMarketVolatilityResponse";
QueryMarketVolatilityResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "volatility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "history_metadata", kind: "message", T: MetadataStatistics },
    { no: 3, name: "raw_history", kind: "message", T: TradeRecord, repeated: true },
]);
/**
 * QuerBinaryMarketsRequest is the request type for the Query/BinaryMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBinaryMarketsRequest
 */
export class QueryBinaryMarketsRequest extends Message {
    constructor(data) {
        super();
        /**
         * Status of the market, for convenience it is set to string - not enum
         *
         * @generated from field: string status = 1;
         */
        this.status = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBinaryMarketsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBinaryMarketsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBinaryMarketsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBinaryMarketsRequest, a, b);
    }
}
QueryBinaryMarketsRequest.runtime = proto3;
QueryBinaryMarketsRequest.typeName = "injective.exchange.v1beta1.QueryBinaryMarketsRequest";
QueryBinaryMarketsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryBinaryMarketsResponse is the response type for the Query/BinaryMarkets
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBinaryMarketsResponse
 */
export class QueryBinaryMarketsResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.BinaryOptionsMarket markets = 1;
         */
        this.markets = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryBinaryMarketsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryBinaryMarketsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryBinaryMarketsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryBinaryMarketsResponse, a, b);
    }
}
QueryBinaryMarketsResponse.runtime = proto3;
QueryBinaryMarketsResponse.typeName = "injective.exchange.v1beta1.QueryBinaryMarketsResponse";
QueryBinaryMarketsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: BinaryOptionsMarket, repeated: true },
]);
/**
 * QueryConditionalOrdersRequest is the request type for the
 * Query/ConditionalOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest
 */
export class QueryTraderDerivativeConditionalOrdersRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string subaccount_id = 1;
         */
        this.subaccountId = "";
        /**
         * @generated from field: string market_id = 2;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderDerivativeConditionalOrdersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderDerivativeConditionalOrdersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderDerivativeConditionalOrdersRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderDerivativeConditionalOrdersRequest, a, b);
    }
}
QueryTraderDerivativeConditionalOrdersRequest.runtime = proto3;
QueryTraderDerivativeConditionalOrdersRequest.typeName = "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest";
QueryTraderDerivativeConditionalOrdersRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder
 */
export class TrimmedDerivativeConditionalOrder extends Message {
    constructor(data) {
        super();
        /**
         * price of the order
         *
         * @generated from field: string price = 1;
         */
        this.price = "";
        /**
         * quantity of the order
         *
         * @generated from field: string quantity = 2;
         */
        this.quantity = "";
        /**
         * margin of the order
         *
         * @generated from field: string margin = 3;
         */
        this.margin = "";
        /**
         * price to trigger the order
         *
         * @generated from field: string triggerPrice = 4;
         */
        this.triggerPrice = "";
        /**
         * true if the order is a buy
         *
         * ensure omitempty is not in jsontag
         *
         * @generated from field: bool isBuy = 5;
         */
        this.isBuy = false;
        /**
         * @generated from field: bool isLimit = 6;
         */
        this.isLimit = false;
        /**
         * @generated from field: string order_hash = 7;
         */
        this.orderHash = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new TrimmedDerivativeConditionalOrder().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TrimmedDerivativeConditionalOrder().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TrimmedDerivativeConditionalOrder().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(TrimmedDerivativeConditionalOrder, a, b);
    }
}
TrimmedDerivativeConditionalOrder.runtime = proto3;
TrimmedDerivativeConditionalOrder.typeName = "injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder";
TrimmedDerivativeConditionalOrder.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "triggerPrice", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "isLimit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse
 */
export class QueryTraderDerivativeConditionalOrdersResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder orders = 1;
         */
        this.orders = [];
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryTraderDerivativeConditionalOrdersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryTraderDerivativeConditionalOrdersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryTraderDerivativeConditionalOrdersResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryTraderDerivativeConditionalOrdersResponse, a, b);
    }
}
QueryTraderDerivativeConditionalOrdersResponse.runtime = proto3;
QueryTraderDerivativeConditionalOrdersResponse.typeName = "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse";
QueryTraderDerivativeConditionalOrdersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeConditionalOrder, repeated: true },
]);
/**
 * @generated from message injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest
 */
export class QueryMarketAtomicExecutionFeeMultiplierRequest extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string market_id = 1;
         */
        this.marketId = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketAtomicExecutionFeeMultiplierRequest, a, b);
    }
}
QueryMarketAtomicExecutionFeeMultiplierRequest.runtime = proto3;
QueryMarketAtomicExecutionFeeMultiplierRequest.typeName = "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest";
QueryMarketAtomicExecutionFeeMultiplierRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * @generated from message injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse
 */
export class QueryMarketAtomicExecutionFeeMultiplierResponse extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string multiplier = 1;
         */
        this.multiplier = "";
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(QueryMarketAtomicExecutionFeeMultiplierResponse, a, b);
    }
}
QueryMarketAtomicExecutionFeeMultiplierResponse.runtime = proto3;
QueryMarketAtomicExecutionFeeMultiplierResponse.typeName = "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse";
QueryMarketAtomicExecutionFeeMultiplierResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
//# sourceMappingURL=query_pb.js.map